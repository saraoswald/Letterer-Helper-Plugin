/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./src/Manga-Scripts/Adjust Size and Leading.js":
/*!******************************************************!*\
  !*** ./src/Manga-Scripts/Adjust Size and Leading.js ***!
  \******************************************************/
/***/ ((module) => {

eval("// ----------- Adjust Size and Leading ----------- // \n/* \n    Increases the size and leading of a selected text frame by the user's leading setting. \n        - Change this setting in Preferences > Units & Increments > Keyboard Increments > Size/Leading\n\n    Updated: Aug 5 2023 - Sara Linsley\n*/\n\nconst doAdjust = function(isIncrease) {\n    if (app.documents.length < 1) return;\n    var hasErrors = false,\n        selections = app.selection;\n\n    for (var i = 0; i < selections.length && !hasErrors; i++) {\n        var textFrame = selections[i].constructorName == \"InsertionPoint\" ?\n            selections[i].parentTextFrames[0] :\n            selections[i];\n        // use the document's increment setting for convenience\n        var increment = app.activeDocument.textPreferences.leadingKeyIncrement;\n        // increase the leading and font size for all the paragraphs in the frame\n        var modifier = isIncrease ? 1 : -1;\n        forEach(textFrame.paragraphs, adjustSizeAndLeading(increment * modifier));\n    }\n}\n\nconst adjustSizeAndLeading = function(increment) {\n    return function(paragraph) {\n        // Increase the font size\n        paragraph.pointSize = paragraph.pointSize + increment;\n\n        // Increase the leading size\n        var currentLeadingValue = paragraph.leading;\n        // if the leading is already set to \"Auto\", then compute the current leading value\n        if (!parseInt(paragraph.leading)) {\n            currentLeadingValue = (paragraph.autoLeading / 100) * paragraph.pointSize;\n        }\n        // add increment to current value\n        paragraph.leading = currentLeadingValue + increment;\n    }\n}\n\n// basically Array.forEach\nconst forEach = function(arr, fn) {\n    for (var i = 0; i < arr.count(); i++) {\n        fn(arr.item(i));\n    }\n}\n\nconst increase = () => doAdjust(true) \nconst decrease = () => doAdjust(false)\n\nmodule.exports = { decrease, increase }\n\n//# sourceURL=webpack://letterer-helper-plugin/./src/Manga-Scripts/Adjust_Size_and_Leading.js?");

/***/ }),

/***/ "./src/Manga-Scripts/Manga Em Dash.js":
/*!********************************************!*\
  !*** ./src/Manga-Scripts/Manga Em Dash.js ***!
  \********************************************/
/***/ ((module) => {

eval("// ----------- Manga Em Dash ----------- // \n/*\n    When run on a text frame, this script will do three things:\n        - change all of the em dashes (—) to hyphens (-)\n        - create a new Character Style named \"200% Width\", which sets the Horizontal Scale to 200%\n        - applies that character style to all the hyphens\n\n    Use case:\n        Some fonts use a double-dash glyph for em dashes, and we have to change them to be long hyphens. \n        This script handles the manual work of changing dashes.\n\n    To use:\n        - Select a text frame \n        - Run script\n    More info on running scripts here: https://github.com/saraoswald/Manga-Scripts\n*/\n\n\n// creates a new Character Style with these configurations\nvar defaultStyle = {\n    name: '200% Width', // change this to something else if you want to use that specific name for something else\n    horizontalScale: 200,\n};\n\nfunction isError(obj) {\n    if (!(obj instanceof ID.TextFrame)) {\n        alert('Please select only text frames and try again');\n        return true;\n    }\n    return false;\n}\n\nfunction applyMangaDash(srcObj) {\n    var doc = app.activeDocument;\n    \n    // Check to see if the Character Style already exists\n    var existingStyle = doc.characterStyles.itemByName(defaultStyle.name);\n    var targetStyle = existingStyle.isValid ?\n        existingStyle :\n        doc.characterStyles.add(defaultStyle);\n\n    // loop through all of the paragraphs\n    for (var i = 0; i < srcObj.paragraphs.length; i++) {\n        // loop through all of the characters in each paragraph\n        var chars = srcObj.paragraphs.item(i).characters;\n        for (var j = 0; j < chars.length; j++) {\n            var ch = chars.item(j).contents;\n            // if the character is an em dash or en dash\n            if ([\"EM_DASH\", \"EN_DASH\"].indexOf(ch.toString()) >= 0) {\n                // change it to a hyphen, and apply the 200% Width character style\n                srcObj.paragraphs.item(i).characters.item(j).contents = '-';\n                srcObj.paragraphs.item(i).characters.item(j).applyCharacterStyle(targetStyle);\n            }\n        }\n    }\n}\n\n// reuseable helper function\n// applies given operation to a text frame,\n// whether the cursor is inside of the text frame or not\nfunction tryCatch(operation) {\n    if (app.documents.length < 1) return;\n    var hasErrors = false,\n        selections = app.selection;\n    for (var i = 0; i < selections.length; i++) {\n        try {\n            var textFrame = selections[i] instanceof ID.InsertionPoint ?\n                selections[i].parentTextFrames[0] :\n                selections[i];\n\n            var frameHasErrors = isError(textFrame);\n            hasErrors = hasErrors || isError(textFrame);\n\n            if (!frameHasErrors) {\n                operation(textFrame);\n            };\n        } catch (e) {\n            console.log(e);\n        }\n    }\n}\n\nfunction main() {\n    tryCatch(applyMangaDash)\n}\n\nmodule.exports = { main }\n\n//# sourceURL=webpack://letterer-helper-plugin/./src/Manga-Scripts/Manga_Em_Dash.js?");

/***/ }),

/***/ "./src/Manga-Scripts/Pseudo-Stroke.js":
/*!********************************************!*\
  !*** ./src/Manga-Scripts/Pseudo-Stroke.js ***!
  \********************************************/
/***/ ((module) => {

eval("// ----------- Pseudo Stroke ----------- // \n/*  Creates a duplicate object with a stroke behind your selected TextFrame\n    This is an alternative to using Outer Glow, which creates grayscale aliasing \n\n    To use:\n        - Select a text frame\n        - Run script from script panel\n    More info on running scripts here: https://github.com/saraoswald/Manga-Scripts\n*/\n\nvar PARENT_LABEL = 'hasPseudoStroke'; // label placed on the final result group \nvar OUTLINE_LABEL = 'isStrokeGroup'; // label placed on just the background outlines;\n\n// check for label \nfunction hasPseudoStroke(obj) {\n    return obj.isValid && obj.extractLabel(PARENT_LABEL) === 'true';\n}\n\n// find condition within a Group\n// returns immediately once the mapper function returns true\nfunction find(group, mapFn) {\n    if (!group || !(group instanceof ID.Group) || !group.allPageItems || group.allPageItems.length < 1) {\n        return false;\n    }\n    var children = group.allPageItems;\n    var i = 0;\n    var found = false;\n    while (i < children.length) {\n        if (mapFn(children[i])) {\n            found = true;\n            break;\n        }\n        i++;\n    }\n    return found;\n}\n\nfunction childHasPseudoStroke(obj) {\n    // if it's not a group, or it's magically empty, return false\n    var mapFn = function(child) { return hasPseudoStroke(child) };\n    return find(obj, mapFn);\n}\n\nfunction childIsTextFrame(obj) {\n    var mapFn = function(child) { return child instanceof ID.TextFrame };\n    return find(obj, mapFn);\n}\n\n// check for outline label\nfunction isOutlineGroup(obj) {\n    return obj.extractLabel(OUTLINE_LABEL) === 'true';\n}\n\n// This has only been tested on Text Frames and Outlines. I don't know what else y'all need to stroke, but this won't do it\nfunction isError(obj) {\n    if (!(obj instanceof ID.TextFrame || obj instanceof ID.Group || obj instanceof ID.Polygon)) {\n        return true;\n    }\n    return false;\n}\n\nfunction outline(obj) {\n    if (obj instanceof ID.Group) {\n        var children = obj.allPageItems;\n        obj.ungroup();\n        var outlineArr = new Array();\n        for (var i = 0; i < children.length; i++) {\n            if (children[i].createOutlines) {\n                var childOutlines = children[i].createOutlines();\n                // I could not get Array.concat to work for the life of me\n                for (var j = 0; j < childOutlines.length; j++)\n                    outlineArr.push(childOutlines[j]);\n            }\n        }\n        return outlineArr;\n    } else return obj.createOutlines();\n}\n\nfunction doAddStroke(srcObj) {\n    // creates a new Character Style with these configurations\n    var defaultObject = {\n        name: 'Stroke 2pt Paper', // change this to something else if you want to use that specific name for something else\n        strokeWeight: '2pt',\n        strokeColor: 'Paper',\n        endJoin: ID.OutlineJoin.ROUND_END_JOIN\n    };\n    // Check to see if the target character style already exists. If so, use it. If not, create it.\n    var existingStyle = app.activeDocument.objectStyles.itemByName(defaultObject.name);\n    var targetStyle = existingStyle.isValid ?\n        existingStyle :\n        app.activeDocument.objectStyles.add(defaultObject);\n    var finalGroup = new Array(srcObj);\n\n    // duplicate the object in place\n    var duplicate = srcObj.duplicate();\n    var outlines = srcObj instanceof ID.TextFrame || childIsTextFrame(srcObj) ?\n        outline(duplicate) :\n        new Array(duplicate);\n    var formattedOutlines = new Array();\n    var needToGroupOutlines = false;\n    // apply the style to every new outline created\n    for (var i = 0; i < outlines.length; i++) {\n        outlines[i].applyObjectStyle(targetStyle);\n        formattedOutlines.push(outlines[i]);\n\n        if (outlines[i] instanceof ID.Group) {\n            outlines[i].insertLabel(OUTLINE_LABEL, 'true');\n            finalGroup.push(outlines[i]);\n        } else needToGroupOutlines = true;\n    }\n    if (needToGroupOutlines) {\n        var groupedOutlines = null;\n        if (formattedOutlines.length > 1) {\n            groupedOutlines = app.activeDocument.groups.add(formattedOutlines);\n        } else if (formattedOutlines.length == 1) {\n            groupedOutlines = formattedOutlines[0];\n        }\n        groupedOutlines.insertLabel(OUTLINE_LABEL, 'true');\n        finalGroup.push(groupedOutlines);\n    }\n\n    srcObj.bringToFront();\n\n    var newGroup = app.activeDocument.groups.add(finalGroup);\n    newGroup.insertLabel(PARENT_LABEL, 'true');\n    return newGroup;\n}\n\nfunction addStroke(srcObj) {\n\n    return new Array(doAddStroke(srcObj));\n}\n\nfunction doRemoveStroke(srcObj) {\n    try {\n        // ungroup the Group we made in doAddStroke, then remove the outlines group\n        var childItems = srcObj.allPageItems;\n        srcObj.ungroup();\n        var i = 0;\n        while (i < childItems.length) {\n            if (isOutlineGroup(childItems[i])) {\n                childItems[i].remove();\n                break;\n            }\n            i++;\n        }\n        return childItems;\n    } catch (err) {\n        alert(err);\n    };\n}\n\nfunction removeStroke(srcObj) {\n    var resultingGroups = new Array();\n\n    if (srcObj instanceof ID.Group && !hasPseudoStroke(srcObj)) {\n        var children = srcObj.allPageItems;\n        var newGroup = new Array();\n        for (var i = 0; i < children.length; i++) {\n            if (hasPseudoStroke(children[i])) doRemoveStroke(children[i]);\n        }\n        resultingGroups.push(srcObj);\n        // TODO: select groups after removing stroke\n    } else resultingGroups.push(doRemoveStroke(srcObj));\n\n    return resultingGroups;\n}\n\n// determine if stroke should be added or removed\nfunction applyStroke(srcObj) {\n    // check if the group already has a pseudostroke\n    if (hasPseudoStroke(srcObj))\n        return removeStroke(srcObj);\n    // check if one of the group's children has pseudostroke\n    else if (childHasPseudoStroke(srcObj))\n        return removeStroke(srcObj);\n    else return addStroke(srcObj);\n}\n\nfunction main(){\n    var hasErrors = false;\n    var selections = app.selection;\n    var newSelections = new Array();\n    for (var i = 0; i < selections.length && !hasErrors; i++) {\n        hasErrors = isError(selections[i]);\n        if (!hasErrors) {\n            var newGroup = applyStroke(selections[i]);\n            if (newGroup) newSelections.push(newGroup);\n        };\n    }\n    // if (!hasErrors) app.select(newSelections);\n}\n\nmodule.exports = { main }\n\n//# sourceURL=webpack://letterer-helper-plugin/./src/Manga-Scripts/Pseudo-Stroke.js?");

/***/ }),

/***/ "./src/Manga-Scripts/Rainbow Layer Colors.js":
/*!***************************************************!*\
  !*** ./src/Manga-Scripts/Rainbow Layer Colors.js ***!
  \***************************************************/
/***/ ((module) => {

eval("const getRGB = function (i, len) {\n    var place = i > 0 ? i / (len - 1) : i;\n    return [red(place) * 250, green(place) * 250, blue(place) * 250];\n}\n\nconst curve = function (x, xOffset) {\n    return -16 * Math.pow(x - xOffset, 2) + 1\n}\n\nconst red = function (x) {\n    if (x < 0.25) return 1;\n    if (x >= 0.25 && x <= 0.5) return curve(x, 0.25);\n    if (x >= 0.75) return curve(x, 1);\n    return 0;\n}\n\nconst green = function (x) {\n    if (x <= 0.25) return curve(x, 0.25);\n    if (x >= 0.25 && x <= 0.5) return 1;\n    if (x >= 0.5 && x <= 0.75) return curve(x, 0.5);\n    return 0;\n}\n\nconst blue = function (x) {\n    if (x >= 0.5 && x <= 0.75) return curve(x, 0.75);\n    if (x > 0.75) return 1;\n    return 0;\n}\n\nconst main = function () {\n    var layers = app.activeDocument.layers;\n    for (var i = 0; i < layers.length; i++) {\n        layers[i].layerColor = getRGB(i, layers.length);\n    }\n}\n\nmodule.exports = { main }\n\n//# sourceURL=webpack://letterer-helper-plugin/./src/Manga-Scripts/Rainbow_Layer_Colors.js?");

/***/ }),

/***/ "./src/Manga-Scripts/Refit Overset Frames.js":
/*!***************************************************!*\
  !*** ./src/Manga-Scripts/Refit Overset Frames.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// ----------- Refit Overset Frames ----------- // \n/* \n    Refits all of the overflowing frames on either the current page or all pages. \n\n    Usage Instructions: \n    - Select one or many text frames that are overset\n    - Run this script\n\n    This is the same thing as doing `Object > Fitting > Fit Frame to Content`, but on a bunch of text frames at once. \n    UPDATE: Now the script will expand the frame by 1 pixel until it's no longer overset\n\n    Installation Instructions: https://github.com/saraoswald/Manga-Scripts/#how-to-use-scripts-in-indesign\n\n    Nov 21 2020, Sara Linsley\n*/\n\nconst progressBar = __webpack_require__(/*! ./progress_bar.js */ \"./src/Manga-Scripts/progress_bar.js\");\n\n/* ------ Start of Script ------ */\n\nconst myDisplayDialog = function() {\n    var doc = app.activeDocument;\n    var usersUnits = app.scriptPreferences.measurementUnit; // so we can revert 'em back later\n    app.scriptPreferences.measurementUnit = ID.MeasurementUnits.PIXELS;\n\n    var myDialog = app.dialogs.add({ name: \"Refit Overset Frames\" });\n    var pageRangeControl;\n    with(myDialog) {\n        with(dialogColumns.add()) {\n            staticTexts.add({ staticLabel: \"Fit all the overset frames on:\" });\n            pageRangeControl = radiobuttonGroups.add();\n            with(pageRangeControl) {\n                radiobuttonControls.add({ staticLabel: \"All Pages\", checkedState: 0 });\n                radiobuttonControls.add({ staticLabel: \"This Page\", checkedState: 1 });\n            }\n            staticTexts.add({ staticLabel: '' });\n        }\n    }\n    var myReturn = myDialog.show();\n    if (myReturn == true) {\n        try {\n            if (pageRangeControl.selectedButton === 0) { // if \"All Pages\" is selected\n                var pageCount = doc.pages.count();\n                progressBar.start(pageCount);\n                for (var i = 0; i < pageCount; i++) {\n                    fitFramesOnPage(doc.pages.item(i));\n                    progressBar.update(i + 1);\n                }\n                progressBar.hide();\n            } else { // if \"This Page\" is selected \n                fitFramesOnPage(app.activeWindow.activePage);\n            }\n        } catch (err) { console.log(err) }\n\n    } else {\n        myDialog.destroy();\n    }\n    app.scriptPreferences.measurementUnit = usersUnits;\n}\n\n// on a given page, loops through all the text frames\n// if any of the text frames are overset, refit the frame to accomodate the content\nconst fitFramesOnPage = function(page) {\n    try {\n        var textFrames = page.textFrames;\n        for (var i = 0; i < textFrames.count(); i++) {\n            var frame = textFrames.item(i);\n            if (!!frame && frame.overflows) {\n                // try using InDesign's default Fit Frame to Content feature\n                frame.fit(ID.FitOptions.FRAME_TO_CONTENT);\n                // if it doesn't work, expand the frame manually\n                if (frame.overflows) {\n                    doFit(frame);\n                }\n            }\n        }\n    } catch (err) { console.log(err) }\n}\n\n// recursive function that nudges the frame bounds out by 1\n// until the frame is no longer overset\nconst doFit = function(frame) {\n    if (!!frame && !frame.overflows) return;\n    expandFrame(frame, 5);\n    doFit(frame);\n}\n\n// expands a given frame by a given unit\nconst expandFrame = function(frame, by) {\n    frame.geometricBounds = transformCoords(frame.geometricBounds, [by * -1, by * -1, by, by]);\n}\n\n// applies transformations in the format [y1, x1, y2, x2]\nconst transformCoords = function(src, trns) {\n    return [\n        src[0] + trns[0],\n        src[1] + trns[1],\n        src[2] + trns[2],\n        src[3] + trns[3]\n    ];\n}\n\nconst main = function(){\n    try {\n        myDisplayDialog();\n    } catch (error) {\n        console.log(error);\n    }\n}\n\nmodule.exports = { main }\n\n//# sourceURL=webpack://letterer-helper-plugin/./src/Manga-Scripts/Refit_Overset_Frames.js?");

/***/ }),

/***/ "./src/Manga-Scripts/Scale Pages.js":
/*!******************************************!*\
  !*** ./src/Manga-Scripts/Scale Pages.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/* \n    Scale Pages.js\n\n    Updated: Dec 20 2020, Sara Linsley\n    \n    ----------------\n\n    Installation instructions here: https://github.com/saraoswald/Manga-Scripts#how-to-use-scripts-in-indesign\n\n    Purpose: \n        Sometimes a pages that have already been lettered need to be adjusted in size\n        to meet the bleed and margin requirments. This script allows you to scale all\n        of the art and text at once, for multiple pages.\n\n    Usage Instructions: \n        - Open an InDesign document\n        - Run Place Art.js\n        - Provide a factor by which to scale page items\n        - Specify whether to scale a range of pages or all of them\n        - Hit \"OK\"\n\n    Important Notes: \n        - This is a really intensive operation on your computer. It will take a while. \n        - This script *will not* place art on locked layers, so protect your other work by locking layers \n        - This script ignores page binding settings. Page 1 to the script is Page 1 to InDesign. \n*/\n\nconst util = __webpack_require__(/*! ../utility */ \"./src/utility.js\");\nconst progressBar = __webpack_require__(/*! ./progress_bar.js */ \"./src/Manga-Scripts/progress_bar.js\");\n\nfunction myDisplayDialog() {\n    myDialog = app.dialogs.add({ name: \"Scale Pages\" });\n    var supportedPageRangeTypes = [\"Range\", \"All\"];\n    var pageRangeControl, pageRangeInput;\n    var scaleFactor;\n    with(myDialog) {\n        with(dialogColumns.add()) {\n            with(dialogRows.add()) {\n                staticTexts.add({ staticLabel: \"Resize all text and graphics in unlocked layers.\" });\n            }\n            with(dialogRows.add()) {\n                staticTexts.add({ staticLabel: \"Scale Factor:\" });\n                scaleFactor = percentEditboxes.add({ editValue: 100 });\n            }\n\n            with(dialogRows.add()) {\n                staticTexts.add({ staticLabel: \"Pages:\" });\n\n                pageRangeControl = radiobuttonGroups.add();\n                with(pageRangeControl) {\n                    for (var i = 0; i < supportedPageRangeTypes.length; i++) {\n                        radiobuttonControls.add({ staticLabel: supportedPageRangeTypes[i], checkedState: i == 0, minWidth: 65 });\n                    }\n                    pageRangeInput = textEditboxes.add({ editContents: app.activeWindow.activePage.name });\n                }\n            }\n        }\n\n    }\n    var myReturn = myDialog.show();\n    if (myReturn == true) {\n        var needsReview = false;\n        var selectedPageRange = pageRangeControl.selectedButton;\n        var pageRange = selectedPageRange === 0 ? getValidRange(pageRangeInput.editContents) : app.activeDocument.pages;\n\n        if (selectedPageRange === 0 && pageRange.length === 0) {\n            util.showDialog('Please enter a valid page range (e.g. \"12, 32-33\")');\n            needsReview = true;\n        }\n\n        resizePages(scaleFactor.editValue, pageRange)\n\n        if (!needsReview) {\n            myDialog.destroy();\n        }\n    } else {\n        myDialog.destroy();\n    }\n}\n\n\n// returns sorted array of numbers based on given range string\n// e.g. \"11-13, 23\" returns [11,12,13,23]\nfunction getValidRange(inp) {\n    var getRange = function(start, stop) {\n        var res = []\n        for (var i = start; i <= stop; i++) res.push(i); // who needs polyfill when you have for loops amirite\n        return res;\n    }\n\n    var getCleanRange = function(inp) {\n        var nums = inp.split('-');\n        var x = parseInt(nums[0]),\n            y = parseInt(nums[1]) || parseInt(nums[0]);\n        return (nums.length > 0 &&\n            x && y &&\n            x <= y\n        ) ? getRange(x, y) : false;\n    }\n\n    var arr = inp.replace(/\\s/g, '').split(',');\n    var resArr = [];\n    for (var i = 0; i < arr.length; i++) {\n        var cleanRange = getCleanRange(arr[i]);\n        for (var j = 0; cleanRange && j < cleanRange.length; j++) {\n            var pageObj = cleanRange[j] ? app.activeDocument.pages.itemByName(cleanRange[j].toString()) : {};\n            if (pageObj.isValid) {\n                resArr.push(pageObj);\n            }\n        }\n    }\n    return resArr.sort();\n}\n\nvar selectAllOnPage = function() {\n    var filterFrames = function(pageItem) { return !pageItem.itemLayer.locked && !pageItem.locked };\n    var allFrames = app.activeWindow.activePage.pageItems;\n    if (allFrames.count() < 1) return [];\n\n    var selection = filter(app.activeWindow.activePage.pageItems, filterFrames);\n    app.selection = selection;\n    return selection;\n}\n\n\n// returns whether or not a given frame is fully past a page's margins\n// uses the margin as a reference point instead of page bounds or bleed due to floating point issues :/\nfunction isFramePastMargin(page, frame) {\n    var prfs = page.marginPreferences,\n        pb = page.bounds,\n        fb = frame.geometricBounds;\n    return fb[0] <= pb[0] + prfs.top &&\n        fb[1] <= pb[1] + prfs.left &&\n        fb[2] >= pb[2] - prfs.bottom &&\n        fb[3] >= pb[3] - prfs.right;\n}\n\n// takes bounds input and gives output in the form [y1, x1, y2, x2]\n// adds the document setting for bleed, taking into account the gutter\nfunction getPageBleed(page) {\n    var prfs = app.activeDocument.documentPreferences,\n        pb = page.bounds,\n        bleedLeft = page.side == ID.PageSideOptions.RIGHT_HAND ? 0 : prfs.documentBleedOutsideOrRightOffset,\n        bleedRight = page.side == ID.PageSideOptions.LEFT_HAND ? 0 : prfs.documentBleedOutsideOrRightOffset;\n    return [\n        pb[0] - prfs.documentBleedTopOffset, //y1\n        pb[1] - bleedLeft, // x1\n        pb[2] + prfs.documentBleedBottomOffset, // y2\n        pb[3] + bleedRight // x2\n    ]\n}\n\n// Recursively scale the page, starting with 5% increments, \n// until the equillibrium point of 100%\nfunction scaleSelected(factor) {\n    // grab menu actions so we can invoke them later\n    var doScaleUpOne = app.menuActions.itemByName(\"Increase scale by 1%\");\n    var doScaleUpFive = app.menuActions.itemByName(\"Increase scale by 5%\");\n    var doScaleDownOne = app.menuActions.itemByName(\"Decrease scale by 1%\");\n    var doScaleDownFive = app.menuActions.itemByName(\"Decrease scale by 5%\");\n    \n    if (factor === 100) return;\n    if (factor > 104 && doScaleUpFive.enabled) {\n        doScaleUpFive.invoke();\n        scaleSelected(factor - 5);\n    } else if (factor > 100 && doScaleUpOne.enabled) {\n        doScaleUpOne.invoke();\n        scaleSelected(factor - 1);\n    } else if (factor < 96 && doScaleDownFive.enabled) {\n        doScaleDownFive.invoke();\n        scaleSelected(factor + 5);\n    } else if (factor < 100 && doScaleDownOne.enabled) {\n        doScaleDownOne.invoke();\n        scaleSelected(factor + 1);\n    } else { return }\n}\n\n\nfunction resizePages(scaleFactor, pageRange) {\n    if (scaleFactor === 100) return; // don't waste resources if the scale factor wasn't changed\n\n    var resizePage = function(page, i) {\n        progressBar.update(i + 1);\n\n        // change the active page\n        app.activeWindow.activePage = page;\n\n        // select everything that's not in a locked layer on the page\n        var selected = selectAllOnPage();\n        if (selected.length < 1) return;\n\n        // keep track of frames that are past the margin, so that we can refit them to the bleed later\n        var needsToBeFitted = filter(selected, function(s) { return isFramePastMargin(page, s) });\n\n        // scale everything that's selected by the given scale value\n        scaleSelected(scaleFactor);\n\n        // refit anything that was larger than the margin to the bleed\n        // this is intended for base art frames\n        needsToBeFitted.forEach(function(f) { return f.geometricBounds = getPageBleed(page) });\n    }\n    var arrLength;\n    try {\n        arrLength = pageRange.count();\n    } catch (error) {\n        arrLength = pageRange.length;\n    }\n    progressBar.start(arrLength);\n    forEach(pageRange, resizePage);\n    progressBar.hide();\n}\n\n// basically Array.filter\nfunction filter(arr, filterFn) {\n    var res = [];\n    for (var i = 0; i < arr.length; i++) {\n        var item = arr.item ? arr.item(i) : arr.at(i);\n        if (filterFn(item)) {\n            res.push(item);\n        }\n    }\n    return res;\n}\n\n// basically Array.forEach\nconst forEach = function(arr, fn) {\n    try {\n        for (var i = 0; i < arr.count(); i++) {\n            fn(arr.item(i), i);\n        }\n    } catch (error) {\n        for (var i = 0; i < arr.length; i++) {\n            fn(arr[i], i);\n        }\n    }\n}\n\n\nconst main = function(){\n    try {\n        myDisplayDialog();\n    } catch (error) {\n        util.showDialog(error, \"Error\");\n    }\n}\n\nmodule.exports = { main }\n\n//# sourceURL=webpack://letterer-helper-plugin/./src/Manga-Scripts/Scale_Pages.js?");

/***/ }),

/***/ "./src/Manga-Scripts/Skew Frame.js":
/*!*****************************************!*\
  !*** ./src/Manga-Scripts/Skew Frame.js ***!
  \*****************************************/
/***/ ((module) => {

eval("// ----------- Skew Frame ----------- // \n/* \n    Increments the Rotation and Shear X Angle of a text frame by the same amount\n*/\n\nfunction doSkew(skewFactor) {\n    if (app.documents.length < 1) return;\n    var hasErrors = false,\n        selections = app.selection;\n\n    for (var i = 0; i < selections.length && !hasErrors; i++) {\n        var textFrame = selections[i];\n        var frameHasErrors = isError(textFrame);\n        hasErrors = hasErrors || frameHasErrors;\n\n        if (!frameHasErrors) {\n            textFrame.absoluteRotationAngle += skewFactor;\n            textFrame.absoluteShearAngle += skewFactor;\n        };\n    }\n\n    if (hasErrors) {\n        console.log('Some selections were not text frames and were skipped');\n    }\n}\n\nfunction isError(obj) {\n    if (obj.constructorName !== \"TextFrame\") {\n        return true;\n    }\n    return false;\n}\n\nconst left  = () => doSkew(-1);\nconst right = () => doSkew(1);\n\nmodule.exports = { left, right }\n\n//# sourceURL=webpack://letterer-helper-plugin/./src/Manga-Scripts/Skew_Frame.js?");

/***/ }),

/***/ "./src/Manga-Scripts/position.js":
/*!***************************************!*\
  !*** ./src/Manga-Scripts/position.js ***!
  \***************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("﻿/* \r\n    Position.js\r\n\r\n    Updated: Jan 17 2020, Sara Linsley\r\n    \r\n    ----------------\r\n\r\n    Installation instructions here: https://github.com/saraoswald/Manga-Scripts#how-to-use-scripts-in-indesign\r\n\r\n    Purpose: \r\n        Shifts and scales art that's been placed in an InDesign document\r\n\r\n    Usage Instructions: \r\n        - Run Position.js with a document open\r\n        - Specify the scale and shift amounts (in points)\r\n        - Specify which pages to transform\r\n        - Hit OK\r\n        \r\n    Important Notes: \r\n        - This is a really intensive operation on your computer. You might need to do it in batches. \r\n*/\r\n\r\n// const progressBar = require('./progress_bar.js');\r\n\r\nconst util = __webpack_require__(/*! ../utility */ \"./src/utility.js\");\r\n\r\n// Feel free to change the default values\r\nvar defaults = {\r\n    oddPages: {\r\n        enabled: true,\r\n        scale: false,\r\n        scaleFactor: 100,\r\n        shiftRight: 0,\r\n        shiftDown: 0\r\n    },\r\n    evenPages: {\r\n        enabled: true,\r\n        scale: false,\r\n        scaleFactor: 100,\r\n        shiftRight: 0,\r\n        shiftDown: 0\r\n    },\r\n    pageRange: 1, // 0 = Range, 1 = All\r\n};\r\n\r\nfunction myDisplayDialog() {\r\n    myDialog = app.dialogs.add({ name: \"Layout Pages\" });\r\n    var supportedPageRangeTypes = [\"Range\", \"All\"];\r\n    var pageRangeControl, pageRangeInput;\r\n    var oddPages = {};\r\n    var evenPages = {};\r\n    with(myDialog) {\r\n        with(dialogColumns.add()) {\r\n            oddPages.enabledCheckbox = enablingGroups.add({ staticLabel: \"Odd Pages\", checkedState: defaults.oddPages.enabled });\r\n            with(oddPages.enabledCheckbox) {\r\n                with(dialogColumns.add()) {\r\n                    oddPages.scaleCheckbox = checkboxControls.add({ checkedState: defaults.oddPages.scale, staticLabel: \"Set Image Scale:\" });\r\n                    staticTexts.add({ staticLabel: \"Shift Right:\" });\r\n                    staticTexts.add({ staticLabel: \"Shift Down:\" });\r\n                }\r\n                with(dialogColumns.add()) {\r\n                    oddPages.scaleFactor = percentEditboxes.add({ editValue: defaults.oddPages.scaleFactor });\r\n                    oddPages.shiftRight = measurementEditboxes.add({ editValue: defaults.oddPages.shiftRight });\r\n                    oddPages.shiftDown = measurementEditboxes.add({ editValue: defaults.oddPages.shiftDown });\r\n                }\r\n            }\r\n\r\n            with(borderPanels.add()) {\r\n                staticTexts.add({ staticLabel: \"Pages:\" });\r\n\r\n                pageRangeControl = radiobuttonGroups.add();\r\n                with(pageRangeControl) {\r\n                    for (var i = 0; i < supportedPageRangeTypes.length; i++) {\r\n                        radiobuttonControls.add({ staticLabel: supportedPageRangeTypes[i], checkedState: defaults.pageRange == i, minWidth: 65 });\r\n                    }\r\n                    pageRangeInput = textEditboxes.add({ editContents: app.activeWindow.activePage.name });\r\n                }\r\n            }\r\n        }\r\n        with(dialogColumns.add()) {\r\n            evenPages.enabledCheckbox = enablingGroups.add({ staticLabel: \"Even Pages\", checkedState: defaults.evenPages.enabled });\r\n            with(evenPages.enabledCheckbox) {\r\n                with(dialogColumns.add()) {\r\n                    evenPages.scaleCheckbox = checkboxControls.add({ checkedState: defaults.oddPages.scale, staticLabel: \"Set Image Scale:\" });\r\n                    staticTexts.add({ staticLabel: \"Shift Right:\" });\r\n                    staticTexts.add({ staticLabel: \"Shift Down:\" });\r\n                }\r\n                with(dialogColumns.add()) {\r\n                    evenPages.scaleFactor = percentEditboxes.add({ editValue: defaults.evenPages.scaleFactor });\r\n                    evenPages.shiftRight = measurementEditboxes.add({ editValue: defaults.evenPages.shiftRight });\r\n                    evenPages.shiftDown = measurementEditboxes.add({ editValue: defaults.evenPages.shiftDown });\r\n                }\r\n            }\r\n        }\r\n    }\r\n    var myReturn = myDialog.show();\r\n    if (myReturn == true) {\r\n        var needsReview = false;\r\n        var selectedPageRange = pageRangeControl.selectedButton;\r\n        var pageRange = selectedPageRange === 0 ? getValidRange(pageRangeInput.editContents, oddPages.enabledCheckbox.checkedState, evenPages.enabledCheckbox.checkedState) : app.activeDocument.pages;\r\n        var regex = /\\d{3,4}(?=\\_?\\d?\\d?[a-zA-Z]?\\.[A-Za-z]{3,4})/;\r\n\r\n        if (selectedPageRange === 0 && pageRange.length === 0) {\r\n            util.showDialog('Please enter a valid page range (e.g. \"12, 32-33\")', 'Error');\r\n            needsReview = true;\r\n        }\r\n\r\n        var transformPage = function(page, data) {\r\n            if (data.scaleCheckbox.checkedState) {\r\n                scalePage(page, parseInt(data.scaleFactor.editValue));\r\n            };\r\n            shiftPage(page, parseInt(data.shiftRight.editValue), parseInt(data.shiftDown.editValue));\r\n        }\r\n\r\n        try {\r\n            for (var i = 0; i < pageRange.length; i++) {\r\n                var page = pageRange[i];\r\n                transformPage(page, parseInt(page.name) % 2 > 0 ? oddPages : evenPages);\r\n            }\r\n        } catch (err) { \r\n            for (var i = 0; i < pageRange.count(); i++) {\r\n                var page = pageRange.item(i);\r\n                transformPage(page, parseInt(page.name) % 2 > 0 ? oddPages : evenPages);\r\n            }\r\n         }\r\n\r\n        if (!needsReview) {\r\n            myDialog.destroy();\r\n        }\r\n    } else {\r\n        myDialog.destroy();\r\n    }\r\n}\r\n\r\n// returns sorted array of numbers based on given range string\r\n// e.g. \"11-13, 23\" returns [11,12,13,23]\r\nfunction getValidRange(inp, includeOdd, includeEven) {\r\n    var getRange = function(start, stop) {\r\n        var res = []\r\n        for (var i = start; i <= stop; i++) res.push(i); // who needs polyfill when you have for loops amirite\r\n        return res;\r\n    }\r\n\r\n    var getCleanRange = function(inp) {\r\n        var nums = inp.split('-');\r\n        var x = parseInt(nums[0]),\r\n            y = parseInt(nums[1]) || parseInt(nums[0]);\r\n        return (nums.length > 0 &&\r\n            x && y &&\r\n            x <= y\r\n        ) ? getRange(x, y) : false;\r\n    }\r\n\r\n    var arr = inp.replace(/\\s/g, '').split(',');\r\n    var resArr = [];\r\n    for (var i = 0; i < arr.length; i++) {\r\n        var cleanRange = getCleanRange(arr[i]);\r\n        for (var j = 0; cleanRange && j < cleanRange.length; j++) {\r\n            var pageNum = cleanRange[j];\r\n            var pageObj = !!pageNum ? app.activeDocument.pages.itemByName(pageNum.toString()) : {};\r\n            if (pageObj.isValid &&\r\n                (includeOdd && pageNum % 2 > 0) || (includeEven && pageNum % 2 == 0)) { // exclude odd/even values based on checkbox values\r\n                resArr.push(pageObj);\r\n            }\r\n        }\r\n    }\r\n    return resArr.sort();\r\n}\r\n\r\n// resets the horizontal and vertical scale of all the graphics on a page to a given factor\r\nfunction scalePage(page, scaleFactor) {\r\n    if (!page.isValid || scaleFactor === NaN) return;\r\n\r\n    var graphics = page.allGraphics;\r\n    for (var i = 0; i < graphics.length; i++) {\r\n        var gr = graphics[i];\r\n        if (isFramePastMargin(page, gr.parent)) {\r\n            gr.absoluteHorizontalScale = scaleFactor;\r\n            gr.absoluteVerticalScale = scaleFactor;\r\n        }\r\n    }\r\n}\r\n\r\nfunction shiftPage(page, right, down) {\r\n    if (right === 0 && down === 0) return;\r\n\r\n    for (var i = 0; i < page.allGraphics.length; i++) {\r\n        var gr = page.allGraphics[i];\r\n        if (isFramePastMargin(page, gr.parent)) {\r\n            gr.move(undefined, [right, down]);\r\n        }\r\n    }\r\n}\r\n\r\n// returns whether or not a given frame is larger than the page\r\nfunction isFramePastMargin(page, frame) {\r\n    var pageDims = getBounds(page.bounds),\r\n        frameDims = getBounds(frame.geometricBounds);\r\n    return frameDims.height >= pageDims.height &&\r\n        frameDims.width >= pageDims.width;\r\n}\r\n\r\n// converts an array of coordinates into an object in the format {width, height}\r\n// makes math easier to understand :')\r\nfunction getBounds(bounds) {\r\n    // bounds = x1, y1, x2, y2\r\n    return {\r\n        width: bounds[2] - bounds[0],\r\n        height: bounds[3] - bounds[1]\r\n    }\r\n}\r\n\r\nconst main = function(){\r\n    try {\r\n        var usersUnits = app.scriptPreferences.measurementUnit; // so we can revert 'em back later\r\n        app.scriptPreferences.measurementUnit = ID.MeasurementUnits.POINTS;\r\n\r\n        if (app.activeDocument.allGraphics.length === 0) {\r\n            util.showDialog(\"Could not find any linked graphics in this document.\");\r\n        } else if (app.documents.length != 0) {\r\n            myDisplayDialog();\r\n        }\r\n\r\n        app.scriptPreferences.measurementUnit = usersUnits;\r\n    } catch (error) {\r\n        console.log(error);\r\n    }\r\n}\r\n\r\nmodule.exports = { main }\n\n//# sourceURL=webpack://letterer-helper-plugin/./src/Manga-Scripts/position.js?");

/***/ }),

/***/ "./src/Manga-Scripts/progress_bar.js":
/*!*******************************************!*\
  !*** ./src/Manga-Scripts/progress_bar.js ***!
  \*******************************************/
/***/ ((module) => {

eval("const startProgressBar = function(maxValue) {\n    const progressBar = document.getElementById(\"progress_bar\");\n    progressBar.className = \"w-5\";\n    progressBar.setAttribute(\"max_value\", maxValue);\n}\n\n\nconst updateProgressBar = function(currValue) {\n    const progressBar = document.getElementById(\"progress_bar\");\n    const maxValue = progressBar.getAttribute(\"max_value\");\n    // calculate percentage done to nearest 5%\n    const percent = (currValue / maxValue) * 100;\n    const percentRounded = Math.round(percent / 5) * 5;\n\n    progressBar.className = `w-${percentRounded}`;\n}\n\nconst hideProgressBar = function() {\n    const progressBar = document.getElementById(\"progress_bar\");\n    progressBar.className = \"hidden\";\n}\n\nmodule.exports = {\n  start: startProgressBar,\n  update: updateProgressBar,\n  hide: hideProgressBar\n}\n\n//# sourceURL=webpack://letterer-helper-plugin/./src/Manga-Scripts/progress_bar.js?");

/***/ }),

/***/ "./src/inputs.js":
/*!***********************!*\
  !*** ./src/inputs.js ***!
  \***********************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

eval("/*\n    REM: `document` is the plugin\n         `app.activeDocument` is the InDesign document that's currently active\n*/\nconst scripts = __webpack_require__(/*! ./scripts */ \"./src/scripts.js\");\n\nfunction handleClickBindingDirection(e) {\n  if (app.documents.length < 1) return;\n  const newBinding = (e.target.value == \"LEFT_TO_RIGHT\") \n                      ? ID.PageBindingOptions.LEFT_TO_RIGHT\n                      : ID.PageBindingOptions.RIGHT_TO_LEFT;\n  app.activeDocument.documentPreferences.pageBinding = newBinding;\n}\n\nfunction setupBindingDirection() {\n  if (app.documents.length < 1) { return }\n  const currentBinding = app.activeDocument.documentPreferences.pageBinding;\n\n  // Not sure when this is used, but it's possible\n  if (currentBinding == ID.PageBindingOptions.DEFAULT_VALUE)\n    currentBinding = ID.PageBindingOptions.LEFT_TO_RIGHT;\n\n  const currentBindingValue = currentBinding.toString();\n  const bindingDirection = document.querySelector('#binding_direction');\n\n  bindingDirection.value = currentBindingValue;\n  bindingDirection.querySelector(`.${currentBindingValue}`).checked = true;\n}\n\nfunction setupFields(){\n  setupBindingDirection();\n}\n\nfunction setupClickBindings(){\n  document.querySelector('#binding_direction').addEventListener(\"change\", handleClickBindingDirection);\n\n  document.querySelector(\"#adjust-size-and-leading .increase\").onclick = scripts.adjustSizeAndLeading.increase;\n  document.querySelector(\"#adjust-size-and-leading .decrease\").onclick = scripts.adjustSizeAndLeading.decrease;\n  document.querySelector(\"#skew-frame .left\").onclick  = scripts.skewFrame.left;\n  document.querySelector(\"#skew-frame .right\").onclick = scripts.skewFrame.right;\n  document.getElementById(\"refit-overset-frames\").onclick = scripts.refitOversetFrames;\n  document.getElementById(\"scale-pages\").onclick = scripts.scalePages;\n  document.getElementById(\"position-art\").onclick = scripts.positionArt;\n  document.getElementById(\"manga-em-dash\").onclick = scripts.mangaEmDash;\n  document.getElementById(\"pseudo-stroke\").onclick = scripts.pseudoStroke;\n\n  scripts.typeset.setupButtons();\n  scripts.typeset.setupKeyboardShortcuts();\n}\n\nfunction handleChangeContext(evt) {\n  console.log(\"context change\");\n  // check that the event is done\n  if (evt && evt.eventPhase && evt.eventPhase.toString() !== \"DONE\") return;\n  // // check that the panel isn't still loading (prevents multiple calls at the same time)\n  // if (panel && panel.classList.contains(\"loading\")) return;\n  // check that a document is open\n  if (app.documents.count() < 1 || !app.activeDocument) return;\n  // check that the document name has changed \n  // if (currentDocument != \"\" && app.activeDocument.name == currentDocument) return;\n\n  setupFields();\n  setupClickBindings();\n}\n\nfunction initPlugin(){\n  if (!app) { return }\n\n  setupFields();\n  setupClickBindings();\n\n  app.addEventListener(\"afterContextChanged\", handleChangeContext);\n  // TODO: stop pasting on close\n}\n\n(function() {\n  initPlugin();\n})();\n\n\n//# sourceURL=webpack://letterer-helper-plugin/./src/inputs.js?");

/***/ }),

/***/ "./src/rtf2html/index.js":
/*!*******************************!*\
  !*** ./src/rtf2html/index.js ***!
  \*******************************/
/***/ ((module) => {

eval("//*[rtf.js]******************************[http://code.google.com/p/obremsdk/]*\n//\n// JavaScript: Rich Text Format (RTF) Processing\n// Version 0.12\n//\n// RTF is a lot like HTML, text that has mark-up which is also text.  Instead\n// of tags, it uses the concept of control words.  Rather than nested tags,\n// it has blocks enclosed in braces.\n//\n// This module has been designed with three layers of functionality which\n// turns out to correspond with what the RTF Specification 1.3 said of RTF\n// Readers:\n//\n//      1. Low-Level / Tokenizing: At the lowest level is the concept of breaking\n//      an RTF string into tokens, stored as 32-bit integers.  Functions are\n//      provided to get higher-level data using the token, original string, and\n//      index where the token was found.\n//\n//      2. Parsing: Next is the RtfParser object which generically traverses the\n//      RTF control words and blocks.  A map of destination handlers is maintained\n//      for acting on the information in a more meaningful way.\n//\n//      3. Handlers: The destination handlers here will put data into a high-\n//      level 'doc' object as well as convert to HTML.\n//\n//-[RTF Tokens]---------------------------------------------------------------\n//\n// Tokens are represented as 32-bit integers.  Most information can be extra-\n// cted from this number, but missing is the position of the token in the\n// source string and a reference to that string itself.  Thus those three\n// parameters are necessary for some functions, but many others require only\n// the token itself.  A lot of the functions don't even bother calling\n// functions, but rather calculate the values themselves.\n//\n// A token is made up of multiple numeric parts which are packed tightly to-\n// gether using bit-level operations (shifting, masking, etc.).  These bits\n// have the following separation from left (most-significant) to right\n// (least-significant):\n//\n//  31                 15     11     8          0 <-- shift position\n// [1] [0000000000000000] [1111] [000] [11111111]\n// has val:16             skp:4  typ:3 len:8\n//\n// As a C/C++ struct, this would look like so:\n//\n//      struct t_rtf_token\n//      {\n//              unsigned char len;\n//              unsigned typ : 3;\n//              unsigned skp : 4;\n//              unsigned val : 16;\n//              unsigned has : 1;\n//      };\n//\n// These parts are defined as follows:\n//\n//      len: Length of the entire token.  Data tokens can only be 255 characters\n//      because this is limited to 8 bits.  Zero-length tokens are possible for\n//      higher-level purposes, but are never returned from GetRtfTk().\n//\n//      typ: Type of the token which determines how GetRtfTxt() and GetRtfVal()\n//      will react:\n//\n//              0x0: Lexically incorrect data; generally ignored.\n//              0x1: Data.\n//              0x2: Start new destination ({).\n//              0x3: End current destination (}).\n//              0x4: Ignorable destination marker (\\*).\n//              0x5: Symbol.\n//              0x6: Control word.\n//              0x7: Character (value == character value).\n//\n//      skp: Amount of characters to skip to get to the end of a control word,\n//      usually to the start of its numeric value.  Add 2 to the bit value, thus\n//      the possible values are 2 to 17.\n//\n//      val: Numeric value + 32,768 (subtract that number to get actual, signed\n//      value).  This isn't stored at the last 16 bits, because if it was the last\n//      bit MAY be interpreted as the sign (yes for JScript on Win32, no for\n//      JScript on Win64).  This could be detected, but at the cost of processing\n//      power.\n//\n//      has: HAS a numeric value, otherwise GetRtfVal() will return NaN.\n//\n//-[History]------------------------------------------------------------------\n// 2007-09-24 by NeilO .... v0.12: Made part of ObremSDK.\n// 2007-01-28 by NeilO .... Created.\n//\n// (C)opyright 2007++ by Neil C. Obremski;                     New BSD License\n//***********************[http://www.opensource.org/licenses/bsd-license.php]*\n\n//----------------------------------------------------------------------------\n//----------------------------------------------------------------------------\n// Low-Level RTF Functions\n//\n// * NewRtfTk()\n// * GetRtfTk()\n// * RtfTkLen()\n// * RtfTkTxt()\n// * RtfTkChr()\n// * RtfTkCtl()\n// * RtfTkVal()\n// * RtfSkipB()\n// * RtfConst()\n// * RtfPkgOb()\n//\n//----------------------------------------------------------------------------\n//----------------------------------------------------------------------------\n\n//_[NewRtfTk()]_______________________________________________________________\n//\n// Creates a new token and returns the result.  Throws an exception on\n// failure.  This function isn't used so much as it exists to illustrate how\n// tokens are represented.\n//\n// See \"RTF Tokens\" in header comment for more details.\n//\n// typ .................... [ in] Type; 0=invalid, 1=data, 2=push, 3=pop,\n//                                                      4=ignorable, 5=symbol, 6=control, 7=character.\n// len .................... [ in] Length; valid values are 0 to 255.  This is\n//                                                      fixed for types 2, 3, and 4.\n// val .................... [ in] Value; 16-bit signed integer with valid\n//                                                      range of -32,768 to 32,767.  If this is null (or\n//                                                      undefined) then no value is set and the 'has' bit\n//                                                      is set to 0 instead of 1.\n// skp .................... [ in] Skip this number of characters to get to the\n//                                                      end of the control word portion (usually to get to\n//                                                      the value); valid range is 2 (default) to 17.\n//\nfunction NewRtfTk(typ, len, val, skp)\n{\n        // - -\n        // validate type\n        //\n        typ = parseInt(typ);\n        if (isNaN(typ))\n        {\n                throw Error(\"NewRtfTk: Missing or invalid type\");\n        }\n\n        // - -\n        // validate length\n        //\n        len = parseInt(len);\n        if (isNaN(len))\n        {\n                if (2 === typ || 3 === typ)\n                        len = 1;\n                else if (4 === typ)\n                        len = 2;\n                else\n                        throw Error(\"NewRtfTk: Missing length (typ=\" + typ + \")\");\n        }\n\n        // - -\n        // validate value\n        //\n        var has = 1;\n        val = parseInt(val);\n        if (isNaN(val))\n        {\n                has = 0;\n                val = 0;\n        }\n        else if (val < -32768 || val > 32767)\n        {\n                throw Error(\"NewRtfTk: Value \" + val +\n                        \" out of range (-32,768 to 32,767)\");\n        }\n\n        // - -\n        // validate skip\n        //\n        skp = parseInt(skp);\n        if (isNaN(skp))\n        {\n                skp = 0;\n        }\n        else if (skp < 2 || skp > 17)\n        {\n                throw Error(\"NewRtfTk: Skip amount \" + skp +\n                        \" out of range (2 to 17)\");\n        }\n        else\n        {\n                // stored in 4 bits, it must be in 0 to 15 range\n                skp -= 2;\n        }\n\n        // - -\n        // form and return token as 32-bit integer\n        //\n        return (has << 31) | (val << 15) | (skp << 11) | (typ << 8) | len;\n\n} // NewRtfTk()\n\n//_[GetRtfTk()]_______________________________________________________________\n//\n// Parses the next token in a string and returns it.  Since tokens are never\n// longer than 255 characters, this can be used on a partially-loaded RTF\n// string.\n//\n// s ...................... [ in] RTF string.\n// i ...................... [ in] Starting position.\n//\nfunction GetRtfTk(s, i)\n{\n        var c = s.charCodeAt(i);\n        var originalIndex = i;\n        \n        // { open brace\n        if (123 === c)\n        {\n                // NewRtfTk(RtfConst().PUSH);\n                return 513;\n        }\n        // } close brace\n        else if (125 === c)\n        {\n                // NewRtfTk(RtfConst().POP);\n                return 769; \n        }\n        // \\ back slash: control word / special character\n        else if (92 === c)\n        {\n                var len = 1;\n                for (c = s.charCodeAt(++i);\n                        c >= 97 && c <= 122;\n                        c = s.charCodeAt(++i))\n                {\n                        len++;\n                }\n\n                // only read one character, either it's special or invalid\n                if (1 === len)\n                {\n                        // * asterisk == ignorable destination marker\n                        if (42 === c)\n                        {\n                                // NewRtfTk(RtfConst().IGNORABLE);\n                                return 1026;\n                        }\n\n                        // ' apostrophe == symbol with 2-digit hex value\n                        if (39 === c)\n                        {\n                                // invalid (not enough characters left in string)\n                                if (i + 2 > s.length)\n                                        return (s.length - i) + 2;\n\n                                var d1 = s.charCodeAt(++i);\n                                var d2 = s.charCodeAt(++i);\n\n                                if (!((d1 >= 0x30 && d1 <= 0x39)  // 0-9\n                                   || (d1 >= 0x41 && d1 <= 0x46)  // A-F\n                                   || (d1 >= 0x61 && d1 <= 0x66)  // a-f\n                                ) || !((d2 >= 0x30 && d2 <= 0x39)  // 0-9\n                                   || (d2 >= 0x41 && d2 <= 0x46)  // A-F\n                                   || (d2 >= 0x61 && d2 <= 0x66)  // a-f\n                                ))\n                                        return 4; // invalid hex\n\n                                var hex = String.fromCharCode(d1, d2)\n\n                                // tysm: https://stackoverflow.com/a/21648161\n                                var j;\n                                var hexes = hex.match(/.{1,4}/g) || [];\n                                var code = \"\";\n                                        for(j = 0; j<hexes.length; j++) {\n                                                code += String.fromCharCode(parseInt(hexes[j], 16));\n                                }\n                                code = code.charCodeAt(0);\n                                if (code == 133)  code = 8230; // fix ellipsis\n                                if (code == 150)  code = 8211; // fix em-dash\n                                if (code == 151)  code = 8212; // fix en-dash\n\n                                return (1 << 31) | ((code+32768) << 15) | (0 << 11) | (7 << 8) | (2 + 2);\n                        }\n\n                        if\n                        (\n                                c != 92 &&      // \\ backslash\n                                c != 45 &&      // - dash\n                                c != 58 &&      // : colon\n                                c != 95 &&      // _ underscore\n                                c < 123 && c > 126      // { | } ~\n                        )\n                        {\n                                // NewRtfTk(RtfConst().INVALID, 2);\n                                return 2;\n                        }\n\n                        // NewRtfTk(RtfConst().SYMBOL, 2, c);\n                        return (1 << 31) | ((c+32768) << 15) | 1282;\n                }\n                // unicode character\n                // the pattern is \\uXXX\n                //   where XXX is the unicode code\n                if (len == 2 && (s.charCodeAt(originalIndex + 1) == 117)) {\n                        // grab the code\n                        var code = \"\", thisChar = c, thisIndex = originalIndex + 2;\n                        while (thisChar && (thisIndex < originalIndex + 15)) {\n                                thisChar = s.charCodeAt(thisIndex)\n                                \n                                // numbers only pls\n                                if (thisChar <= 47 || thisChar >= 58) break;\n                                \n                                code += s.charAt(thisIndex);\n                                thisIndex++;\n                        }\n\n                        var codeLen = code.length;\n                        code = parseInt(code);\n\n                        return (1 << 31) | ((code+32768) << 15) | (0 << 11) | (5 << 8) | (codeLen + 2);\n                }\n\n                // digits possibly preceded by a hyphen\n                if (45 === c || (c >= 48 && c <= 57))\n                {\n                        var skp = len;\n                        var vi = i;     // start index of value\n\n                        for (c = s.charCodeAt(++i); i < s.length; c = s.charCodeAt(++i))\n                        {\n                                len++;\n                                if (45 !== c && (c < 48 || c > 57))\n                                {\n                                        // space terminator (absorbed into control word token)\n                                        if (32 === c)\n                                                len++;\n                                        break;\n                                }\n                        }\n\n                        // slice is used, not substr, because an explicit index is passed\n                        // rather than a length\n                        var val = parseInt(s.slice(vi, i));\n\n                        // add 32768 to make any value unsigned\n                        val += 32768;\n                        \n                        // NewRtfTk(RtfConst().CONTROL, len, val, skp);\n                        var tk = (1 << 31) | (val << 15) | ((skp-2) << 11) | 1536 | len;\n                        return tk;\n                }\n                // space terminator (absorbed into control word token)\n                else if (32 === c)\n                {\n                        len++;\n\n                        // NewRtfTk(RtfConst().CONTROL, len, null, len - 1);\n                        return ((len-3) << 11) | 1536 | len;\n                }\n\n                // NewRtfTk(RtfConst().CONTROL, len, null, len);\n                return ((len-2) << 11) | 1536 | len;\n        }\n        // CRLF's (logged as symbol in case it's wanted)\n        else if (10 === c || 13 === c)\n        {\n                var len = 1;\n                for (c = s.charCodeAt(++i); i < s.length; c = s.charCodeAt(++i))\n                {\n                        if (10 !== c && 13 !== c)\n                                break;\n                        len++;\n                        if (255 === len)\n                                break;\n                }\n\n                // NewRtfTk(RtfConst().CONTROL, len, 13);\n                return (1 << 31) | 1074169088 | len;\n        }\n\n        // data\n        var len = 1;\n        for (c = s.charCodeAt(++i); i < s.length; c = s.charCodeAt(++i))\n        {\n                if (92 === c || 123 === c || 125 === c || 13 === c || 10 === c)\n                        break;\n                len++;\n                if (255 === len)\n                        break;\n        }\n\n        // NewRtfTk(RtfConst().DATA, len);\n        return (256 | len);\n\n} // GetRtfTk()\n\n//_[RtfTkTyp()]_______________________________________________________________\n//\n// Returns the type of the token.\n//\n// t ...................... [ in] Token; see \"RTF Tokens\".\n//\nfunction RtfTkTyp(t)\n{\n        return (t >> 8) & 0x7;\n}\n\n//_[RtfTkLen()]_______________________________________________________________\n//\n// Returns the length of the token from its starting position.\n//\n// t ...................... [ in] Token; see \"RTF Tokens\".\n//\nfunction RtfTkLen(t)\n{\n        return (t & 0xFF);\n}\n\n//_[RtfTkTxt()]_______________________________________________________________\n//\n// Returns the text of the ENTIRE token.  If only the control word is desired,\n// from that token type, then use RtfTkCtl().\n//\n// t ...................... [ in] Token; see \"RTF Tokens\".\n// s ...................... [ in] Source string.\n// i ...................... [ in] Starting index where token was found.\n//\nfunction RtfTkTxt(t, s, i)\n{\n        return s.substr(i, t & 0xFF);\n}\n\n//_[RtfTkChr()]_______________________________________________________________\n//\n// Returns a string with a length of 1, for character tokens or symbols.\n//\n// t ...................... [ in] Token; see \"RTF Tokens\".\n// s ...................... [ in] Source string.\n// i ...................... [ in] Starting index where token was found.\n//\nfunction RtfTkChr(t, s, i)\n{\n        if (1792 !== (t & 0x700) && 1280 !== (t & 0x700))\n                return null;\n\n        return String.fromCharCode(((t >> 15) & 0xFFFF) - 32768);\n}\n\nfunction RtfTkHex(t) {\n        var str = String.fromCharCode(((t >> 15) & 0xFFFF) - 32768);\n        return str;\n}\n\n//_[RtfTkCtl()]_______________________________________________________________\n//\n// Returns the control word portion of the token (e.g. without numeric value\n// or preceding backslash).  Returns null if the token is not a control word.\n//\n// t ...................... [ in] Token; see \"RTF Tokens\".\n// s ...................... [ in] Source string.\n// i ...................... [ in] Starting index where token was found.\n//\nfunction RtfTkCtl(t, s, i)\n{\n        if (1536 !== (t & 0x700))\n                return null;\n\n        return s.substr(1 + i, 1 + ((t >> 11) & 0xF));\n}\n\n//_[RtfTkVal()]_______________________________________________________________\n//\n// Returns the numeric value of the token or NaN if it doesn't have one.\n// Symbols return their character index.\n//\n// t ...................... [ in] Token; see \"RTF Tokens\".\n//\nfunction RtfTkVal(t)\n{\n        if (0 === (t >> 31))\n                return NaN;\n\n        return ((t >> 15) & 0xFFFF) - 32768;\n}\n\n//_[RtfSkipB()]_______________________________________________________________\n//\n// Skip a block ({ ... }) of RTF tokens.  Returns the position PAST the\n// closing brace.\n//\n// s ...................... [ in] Source string.\n// i ...................... [ in] Starting index.\n// bc ..................... [ in] Brace Count; defaults to zero (0).\n//\nfunction RtfSkipB(s, i, bc)\n{\n        if (null == bc)\n                bc = 0;\n\n        var ps = i;\n        var tl = 0;\n\n        for (var ps = i; ps < s.length; ps += tl)\n        {\n                var tk = GetRtfTk(s, ps);\n                var tl = tk & 0xFF;\n                var ty = (tk >> 8) & 0x7;\n\n                if (2 === ty)\n                {\n                        bc++;\n                }\n                else if (3 === ty)\n                {\n                        if (0 === bc)\n                        {\n                                ps += tl;\n                                break;\n                        }\n                        else\n                        {\n                                bc--;\n                        }\n                }\n        }\n\n        return ps;\n\n} // RtfSkipB()\n\n//_[RtfConst()]_______________________________________________________________\n//\n// Returns an object of known RTF constants.\n//\nfunction RtfConst()\n{\n        if (null != RtfConst.dic)\n                return RtfConst.dic;\n\n        RtfConst.dic =\n        {\n                //\n                // token types\n                //\n                INVALID                                         : 0,\n                DATA                                            : 1,\n                PUSH                                            : 2,\n                POP                                                     : 3,\n                IGNORABLE                                       : 4,\n                SYMBOL                                          : 5,\n                CONTROL                                         : 6,\n                CHARACTER                                       : 7,\n\n                //\n                // \\fcharset (Character set)\n                //\n                ANSI_CHARSET                            : 0,\n                SYMBOL_CHARSET                          : 2,\n                SHIFTJIS_CHARSET                        : 128,\n                GREEK_CHARSET                           : 161,\n                TURKISH_CHARSET                         : 162,\n                HEBREW_CHARSET                          : 177,\n                ARABICSIMPLIFIED_CHARSET        : 178,\n                ARABICTRADITIONAL_CHARSET       : 179,\n                ARABICUSER_CHARSET                      : 180,\n                HEBREWUSER_CHARSET                      : 181,\n                CYRILLIC_CHARSET                        : 204,\n                EASTERNEUROPE_CHARSET           : 238,\n                PC437_CHARSET                           : 254,\n                OEM_CHARSET                                     : 255,\n                \n                //\n                // \\fprq (pitch)\n                //\n                PitchDefault                            : 0,\n                PitchFixed                                      : 1,\n                PitchVariable                           : 2\n        };\n\n        return RtfConst.dic;\n\n} // RtfConst()\n\n//_[RtfPkgOb()]_______________________________________________________________\n//\n// Parses an embedded object (\\objdata) where the class is \"Package\"\n// (\\objclass); returns an object representing the package.  Currently this\n// has the following members:\n//\n//      * label: The label for the entire package.\n//      * size: The size of the package (not very useful once parsed).\n//      * items[]: An array of files within the package.  Each item has the\n//              properties 'name', 'path' (filename w/ path), and possibly 'data'\n//              which is the file data as a string.\n//\n// IMPORTANT: This function is currently brittle on purpose, because I'm\n// parsing based on tests done in reverse engineering attempts.  It's entirely\n// possible that some of the assumptions here are wrong and I'd like to find\n// those out.\n//\n// txt .................... [ in] RTF source string.\n// beg .................... [ in] Beginning index of package data.\n// end .................... [ in] Ending index of package data (one-past).\n//\nfunction RtfPkgOb(txt, beg, end)\n{\n        var pkg = { };\n        var i = beg;\n        var c = null;\n        var n = null;\n\n        // first 4 bytes should be: 01 05 00 00\n        n = be4_();\n        if (0x01050000 !== n)\n                throw Error(\"Expected: 01 05 00 00; Instead: \" + n.toString(16));\n\n        // second 4 bytes should be: 02 00 00 00\n        n = le4_();\n        if (2 !== n)\n                throw Error(\"Expected: 02 00 00 00 (2); Instead: \" + n);\n\n        // progid length\n        pkg.progid = bstr_(true);\n        trace(\"RtfPkgOb:ProgID = \\\"\" + pkg.progid + \"\\\"\");\n\n        if (0 != le4_() || 0 != le4_())\n                throw Error(\"Expected two zero numbers!\");\n\n        pkg.totalsz = le4_();\n        trace(\"RtfPkgOb:Total Size = \" + pkg.totalsz);\n\n        // should be at least 2 bytes, no more than 1 megabyte\n        if (pkg.totalsz < 2 || pkg.totalsz > 1048576)\n                throw Error(\"RtfPkgOb: Invalid Size \" + pkg.totalsz);\n\n        // Byte Counter\n        var bc = 0;\n\n        //\n        // read string table\n        //\n        \n        pkg.strings = new Array(le2_());\n        bc += 2;\n        dtrace(\"RtfPkgOb:Strings.length = \" + pkg.strings.length);\n        if (pkg.strings.length < 2 || pkg.strings.length > 10)\n                throw Error(\"RtfPkgOb:Invalid Strings.length (\" +\n                        pkg.strings.length + \")\");\n\n        for (var si = 0; si < pkg.strings.length; si++)\n        {\n                pkg.strings[si] = str_();\n                bc += pkg.strings[si].length;\n                bc ++;\n                trace(\"RtfPkgOb:Strings[\" + si + \"] = \\\"\" + pkg.strings[si] + \"\\\"\");\n        }\n        pkg.label = pkg.strings[0];\n\n        // string table ends with two zeros\n        bc += 2;\n        if (0 != le2_())\n                throw Error(\"RtfPkgOb:Expected Double-Zero's After Strings\");\n\n        //\n        // read OLE type (1 == linked, 3 == static)\n        //\n        pkg.oletype = le2_();\n        bc += 2;\n        trace(\"RtfPkgOb:OLE Type = \" + pkg.oletype);\n        if (1 !== pkg.oletype && 3 !== pkg.oletype)\n                throw Error(\"RtfPkgOb: Unsupported OLE Type (\" + pkg.oletype + \")\");\n\n        //\n        // if static then read through the strings and their data\n        // (bc == byte counter)\n        //\n        var trm = null;\n        if (3 === pkg.oletype)\n        {\n                pkg.items = [ ];\n                while (i < end)\n                {\n                        dtrace((pkg.items.length) + \". (\" + bc + \" / \" +\n                                pkg.totalsz + \")\");\n\n                        // read path\n                        var item = { path : bstr_(true) };\n                        bc += item.path.length;\n                        bc += 5;\n                        dtrace(\"Path=\" + item.path);\n\n                        // read data\n                        item.data = bstr_(false);\n                        bc += item.data.length;\n                        bc += 4;\n\n                        // add to list (name calculated later)\n                        pkg.items.push(item);\n\n                        // if at the end ... break for terminator check\n                        if (bc == pkg.totalsz - 2)\n                                break;\n\n                } // while (read static OLE objects)\n        }\n        else if (1 === pkg.oletype)\n        {\n                pkg.items = new Array(le2_());\n                bc += 2;\n                dtrace(\"Items Length == \" + pkg.items.length);\n\n                for (var si = 0; si < pkg.items.length; si++)\n                {\n                        var item = { path : str_() };\n                        trace(\"Item Path [\" + si + \"]: \" + item.path);\n                        bc += item.path.length;\n                        bc ++;\n                        \n                        if (item.path.indexOf(\"~\") >= 0)\n                        {\n                                trace(\"Reset Item Path to \" + pkg.label);\n                                item.path = pkg.label;\n                        }\n                        pkg.items[si] = item;\n                }\n\n                if (bc != pkg.totalsz - 2)\n                        throw Error(\"RtfPkgOb: Wasted Data (\" + (pkg.totalsz - 2 - bc) + \")\");\n        }\n\n        // check terminator\n        var trm = le2_();\n        if (0 != trm)\n                throw Error(\"RtfPkgOb: Invalid Terminator (\" + trm + \")\");\n\n        //\n        // create items' name property ...\n        //\n        for (var j = 0; j < pkg.items.length; j++)\n        {\n                var item = pkg.items[j];\n                var si = item.path.lastIndexOf(\"\\\\\");\n                if (si > 0)\n                        item.name = item.path.substr(si + 1);\n                else\n                        item.name = item.path;\n        }\n\n        return pkg;\n\n        // - - - end of function / private methods follow - - -\n\n        // read 4-byte big endian integer\n        function be4_()\n        {\n                return (hx_() << 28) | (hx_() << 24) | (hx_() << 20) | (hx_() << 16) |\n                        (hx_() << 12) | (hx_() <<  8) | (hx_() <<  4) | hx_();\n        }\n\n        // read 4-byte little endian integer\n        function le4_()\n        {\n                return (hx_() << 4) | (hx_()) | (hx_() << 12) | (hx_() <<  8) |\n                        (hx_() << 20) | (hx_() << 16) | (hx_() << 28) | (hx_() << 24);\n        }\n\n        // read 2-byte little endian integer\n        function le2_()\n        {\n                return (hx_() << 4) | (hx_()) | (hx_() << 12) | (hx_() <<  8);\n        }\n\n        // read binary string that is preceded by a 4-byte length\n        // (zt == zero terminated?)\n        function bstr_(zt)\n        {\n                var len = le4_();\n                dtrace(\"Len: \" + len + \" (\" + i + \", \" + end + \")\");\n\n                if (i + len > end)\n                        throw Error(\"RtfPkgOb/bstr_: Out of Data\");\n\n                var a = [ ];\n                var cnt = 0;\n                var hs = [ ];\n\n                while (i < end)\n                {\n                        var c = (hx_() << 4) | hx_();\n\n                        a.push(c);\n                        cnt++;\n                        if (cnt >= len)\n                                break;\n                        if (a.length > 500)\n                        {\n                                hs.push(String.fromCharCode.apply(null, a));\n                                a = [ ];\n                        }\n                }\n                if (a.length > 0)\n                {\n                        hs.push(String.fromCharCode.apply(null, a));\n                        a = [ ];\n                }\n\n                var s = hs.join(\"\");\n                if (true === zt)\n                {\n                        if (0 !== s.charCodeAt(s.length - 1))\n                                throw Error(\"RtfPkgOb/bstr_: Unterminated String (\" +\n                                        s.charCodeAt(s.length - 1) + \")\");\n                        s = s.substr(0, s.length - 1);\n                }\n\n                return s;\n        }\n\n        // read string that is zero (null) terminated w/ no length prefix\n        function str_()\n        {\n                var a = [ ];\n                var hs = [ ];\n\n                while (i < end)\n                {\n                        var c = (hx_() << 4) | hx_();\n                        if (0 == c)\n                                break;\n                        a.push(c);\n                        if (a.length > 500)\n                        {\n                                hs.push(String.fromCharCode.apply(null, a));\n                                a = [ ];\n                        }\n                }\n                if (a.length > 0)\n                {\n                        hs.push(String.fromCharCode.apply(null, a));\n                        a = [ ];\n                }\n\n                return hs.join(\"\");\n        }\n\n        // read hex character\n        function hx_()\n        {\n                // read character, skipping white space\n                do\n                {\n                        c = txt.charCodeAt(i++);\n                } while (32 === c || 13 === c || 10 === c);\n\n                if (c >= 0x30 && c <= 0x39)\n                        return c - 0x30;\n                if (c >= 0x41 && c <= 0x5A)\n                        return c - 0x37;\n                if (c >= 0x61 && c <= 0x7A)\n                        return c - 0x57;\n                if (i >= end)\n                        throw Error(\"RtfPkgObj/hx_: Out of Data\");\n\n                throw Error(\"RtfPkgOb/hx_: Unexpected Code (\" + c + \"): '\" +\n                        txt.charAt(i-1) + \"' @ \" + i + \" / \" + end);\n        }\n\n} // RtfPkgOb()\n\n//----------------------------------------------------------------------------\n//----------------------------------------------------------------------------\n// RtfParser Object\n//\n// Quick feature list:\n// * Keeps track of stack\n// * Skips ignore-able, unhandled destinations\n// * Calls functions based on their mapping to destination names/paths\n//\n//----------------------------------------------------------------------------\n//----------------------------------------------------------------------------\n\n//_[RtfParser()]______________________________________________________________\n//\n// text ................... [ in] Rich text formatted string.\n// strict ................. [ in] Enable strict format-checking handlers?\n//                                                      (reserved; currently does nothing)\n// nohandle ............... [ in] Do NOT enable basic destination handlers?\n//\nfunction RtfParser(text, strict, nohandle)\n{\n        var pt = RtfParser.prototype;\n        if (true !== pt.__PtInit)\n        {\n                pt.Template             = RtfParser__Template;\n                pt.HandleDest   = RtfParser__HandleDest;\n                pt.Handlers             = RtfParser__Handlers;\n                pt.Document             = RtfParser__Document;\n\n                pt.HandlePcData = RtfParser__HandlePcData;\n                pt.HandleIgnore = function(){};\n\n                pt.__PtInit = true;\n        }\n\n        if (null == text)\n                throw Error(\"RtfParser: Missing source RTF string\");\n\n        this.txt        = text; // source text\n        this.pos        = 0;    // position in source text\n        this.doc        = { };  // document object\n        this.stk        = [ ];  // parsing stack\n        this.frm        = { };  // current stack frame\n\n        // destination handler collections\n        //      dhd: dictionary where keys are either names or paths\n        //      dhr: list of regular expressions, every other is handler reference\n        this.dhd        = { };\n        this.dhr        = [ ];\n\n        // destination handler cache\n        this.dhc        = { };\n        this._chit      = 0; // cache hits\n        this._cmis      = 0; // cache misses\n\n        // enable basic handlers\n        if (true !== nohandle)\n        {\n                this.HandleDest(\";rtf\", HandleMeta);\n                this.HandleDest(\";rtf;fonttbl\", HandleFontTable);\n                this.HandleDest(\";rtf;fonttbl;f\", HandleFontTable);\n                this.HandleDest(\";rtf;colortbl\", HandleColorTable);\n        }\n\n        return; // constructor finished; methods follow - - -\n\n        //_[RtfParser::Template()]________________________________________________\n        //\n        // Template destination handler function.\n        //\n        // t .................. [ in] Token.\n        // s .................. [ in] Source string.\n        // i .................. [ in] Index of token in source string.\n        // o .................. [ in] Current stack frame.\n        //\n        function RtfParser__Template(t, s, i, o)\n        {\n                // do not return any value, this version ignores return values but a\n                // future one might do something with them\n        }\n\n        //_[RtfParser::HandleDest()]______________________________________________\n        //\n        // Maps a destination to a handler function.  Destinations can be specif-\n        // ied in three ways: a regular expression which will match against the\n        // full path, a single name, or a full path.  Since control words are\n        // always lower-case, case is not an issue.  Full paths are specified\n        // using semi-colons, i.e. \";rtf;fonttbl\".  Note there is no trailing\n        // semi-colon.\n        //\n        // dest ............... [ in] Destination (String or RegExp).\n        // handler ............ [ in] Handler function; see RtfParser::Template()\n        //                                              for an example.\n        //\n        function RtfParser__HandleDest(dest, handler)\n        {\n                // clear cache\n                this.dhc = { };\n                this._chit = 0;\n                this._cmis = 0;\n\n                var i = null;\n\n                if (RegExp === dest.constructor)\n                {\n                        // disallow duplicating the same regexp+handler\n                        var sDest = dest.toString();\n                        for (i = 0; i < this.dhr.length; i += 2)\n                                if (this.dhr[i+1] === handler &&\n                                        this.dhr[i].toString() === sDest)\n                                        break;\n\n                        if (i == this.dhr.length)\n                        {\n                                this.dhr.push(dest);\n                                this.dhr.push(handler);\n                        }\n                }\n                else if (String === dest.constructor)\n                {\n                        var list = this.dhd[dest];\n                        if (null == list)\n                        {\n                                list = this.dhd[dest] = [ handler ];\n                        }\n                        else\n                        {\n                                for (i = 0; i < list.length; i++)\n                                        if (list[i] === handler)\n                                                break;\n\n                                if (i == list.length)\n                                {\n                                        list.push(handler);\n                                }\n                        }\n                }\n                else\n                {\n                        throw Error(\"RtfParser::HandleDest: Invalid destination param\");\n                }\n\n        } // RtfParser::HandleDest()\n\n        //_[RtfParser::Handlers()]________________________________________________\n        //\n        // Returns the list of handlers for the specified destination.\n        //\n        function RtfParser__Handlers(tok, txt, pos, name, path)\n        {\n                // if a list has already been built for this exact stack path ...\n                // (hasOwnProperty is used, because 'null' might be set)\n                if (this.dhc.hasOwnProperty(path))\n                {\n                        this._chit++;\n                        return this.dhc[path];\n                }\n\n                // missed cache, have to build up list from three sources\n                this._cmis++;\n                var dh = [ ];\n\n                // source 1: by name (fonttbl)\n                var a = this.dhd[name];\n                if (null != a)\n                        dh = dh.concat(a);\n\n                // source 2: by path (;rtf;fonttbl)\n                a = this.dhd[path];\n                if (null != a)\n                        dh = dh.concat(a);\n\n                // source 3: regular expressions (/*tbl$/)\n                var j = null;\n                for (var i = 0; i < this.dhr.length; i += 2)\n                {\n                        var fnc = this.dhr[i+1];\n\n                        // prevent duplicating function references\n                        for (j = 0; j < dh.length; j++)\n                                if (dh[j] === fnc)\n                                        break;\n                        if (j < dh.length)\n                                continue;\n\n                        var re = this.dhr[i];\n                        if (re.test(path))\n                                dh.push(fnc);\n                }\n\n                // never return a zero-length array; use null to indicate no handlers\n                if (0 === dh.length)\n                        return (this.dhc[path] = null);\n\n                return (this.dhc[path] = dh);\n\n        } // RtfParser::Handlers()\n\n        //_[RtfParser::Document()]________________________________________________\n        //\n        // Returns the parsed document; that is, if it hasn't already been parsed\n        // then this blocks until it IS parsed.\n        //\n        // incomplete ......... [ in] Allow returning of incomplete document?  By\n        //                                              default this function will block until parsing is\n        //                                              complete.\n        //\n        function RtfParser__Document(incomplete)\n        {\n                // return immediately if 'incomplete' is set OR parsing is complete\n                if (true === incomplete || this.pos === this.txt.length)\n                        return this.doc;\n\n                //\n                // main loop\n                //\n                var tok, len, typ;\n                for ( ; this.pos < this.txt.length; this.pos += len)\n                {\n                        tok = GetRtfTk(this.txt, this.pos);\n                        len = tok & 0xFF;\n                        typ = (tok >> 8) & 0x7;\n\n                        // - -\n                        // open brace, push new destination\n                        //\n                        if (2 === typ)\n                        {\n                                var btk = tok;\n                                var bps = this.pos;\n\n                                // read token immediately following open brace\n                                this.pos += len;\n                                tok = GetRtfTk(this.txt, this.pos);\n                                len = tok & 0xFF;\n                                typ = (tok >> 8) & 0x7;\n\n                                // ignorable destination marker\n                                var ign = false;\n                                if (4 === typ)\n                                {\n                                        ign = true;\n\n                                        // read token PAST marker\n                                        this.pos += len;\n                                        tok = GetRtfTk(this.txt, this.pos);\n                                        len = tok & 0xFF;\n                                        typ = (tok >> 8) & 0x7;\n                                }\n\n                                // // token MUST be control word\n                                // if (6 !== typ)\n                                //         throw Error(\"RtfParser: No control after open brace! Position: \" + this.pos);\n\n                                // create new stack frame with stuff we know about (handlers\n                                // should be careful about using ANY three-character var name)\n                                var nfr =\n                                {\n                                        tok : tok,\n                                        pos : this.pos,\n                                        ctl : RtfTkCtl(tok, this.txt, this.pos),\n                                        doc : this.doc,\n                                        stk : this.stk\n                                };\n                                \n                                // determine stack path, e.g. the names of all destinations\n                                // joined into one string and separated by semi-colons\n                                if (0 === this.stk.length)\n                                        nfr.pth = \";\" + nfr.ctl;\n                                else\n                                        nfr.pth = this.stk[this.stk.length-1].pth + \";\" + nfr.ctl;\n\n                                // get list of handlers for this destination\n                                nfr._dh = this.Handlers(tok, this.txt, this.pos, nfr.ctl, nfr.pth);\n\n                                // if no handlers found ...\n                                if (null == nfr._dh)\n                                {\n                                        // unrecognized, non-ignorable destination\n                                        // if (true !== ign)\n                                        //         throw Error(\"RtfParser: Unhandled Destination \\\"\" +\n                                        //                 nfr.ctl + \"\\\" (\" + nfr.pth + \")\");\n\n                                        // ignore destination by skipping its block\n                                        this.pos = RtfSkipB(this.txt, this.pos);\n\n                                        // clear length so iteration doesn't increment 'this.pos'\n                                        len = 0;\n                                }\n                                // else (handler(s) found) ...\n                                else\n                                {\n                                        // push our new frame\n                                        this.frm = nfr;\n                                        this.stk.push(nfr);\n\n                                        // call each handler to let them know they're being pushed\n                                        for (var i = 0; i < nfr._dh.length; i++)\n                                                nfr._dh[i](btk, this.txt, bps, nfr);\n                                }\n                        }\n                        // - -\n                        // close brace, pop current destination\n                        //\n                        else if (3 === typ)\n                        {\n                                // this check also prevents a null 'this.frm' from beind used\n                                if (0 === this.stk.length)\n                                        throw Error(\"RtfParser: Too many closing braces!\");\n\n                                // call current destination handlers to let them know they're\n                                // about to be popped\n                                for (var i = 0; i < (this.frm._dh || []).length; i++)\n                                        this.frm._dh[i](tok, this.txt, this.pos, this.frm);\n\n                                this.stk.pop();\n                                if (0 === this.stk.length)\n                                        this.frm = null;\n                                else\n                                        this.frm = this.stk[this.stk.length - 1];\n                        }\n                        // - -\n                        // invalid, text, symbol, control, or character\n                        //\n                        // pass these types to current destination handler(s)\n                        //\n                        else\n                        {\n                                // call current destination handlers with this token\n                                if (null != this.frm)\n                                {\n                                        for (var i = 0; i < (this.frm._dh || []).length; i++)\n                                                this.frm._dh[i](tok, this.txt, this.pos, this.frm);\n                                }\n                                else\n                                {\n                                        // ignored, unprocessed token ... this only happens when\n                                        // there are tokens at the \"global\" level (e.g. before\n                                        // {\\rtf and after final }).  Usually this is for white-\n                                        // space, but I don't think we really care.\n                                }\n                        }\n\n                } // for (main loop)\n        \n                return this.doc;\n\n        } // RtfParser::Document()\n\n        //------------------------------------------------------------------------\n        //------------------------------------------------------------------------\n        // Generic Handlers\n        //\n        // * HandlePcData()\n        //\n        //------------------------------------------------------------------------\n        //------------------------------------------------------------------------\n\n        //_[RtfParser::HandlePcData()]____________________________________________\n        //\n        // Used for destinations which are simply a #PCDATA text string.  A\n        // property of the same name is created on the previous stack frame.\n        //\n        function RtfParser__HandlePcData(t, s, i, o)\n        {\n                if (513 === t)\n                {\n                        o.dat = [ ];\n                        return;\n                }\n                else if (769 === t)\n                {\n                        // previous stack frame\n                        var pfrm = o.stk[o.stk.length-2];\n                        pfrm[o.ctl] = o.dat.join(\"\");\n                        dtrace(\"#PCDATA \" + o.ctl + \"=\\\"\" + pfrm[o.ctl] + \"\\\"\");\n                        return;\n                }\n\n                var typ = RtfTkTyp(t);\n                if (1 !== typ)\n                        throw Error(\"RtfParser: Unexpected type (\" + typ + \") in \\\"\" +\n                                o.ctl + \"\\\" #PCDATA\");\n\n                o.dat.push(RtfTkTxt(t, s, i));\n\n        } // RtfParser::HandlePcData()\n\n        //------------------------------------------------------------------------\n        //------------------------------------------------------------------------\n        // Basic Handlers\n        //\n        // * HandleMeta()\n        // * HandleFontTable()\n        // * HandleColorTable()\n        //\n        //------------------------------------------------------------------------\n        //------------------------------------------------------------------------\n\n        //_[HandleMeta()]_________________________________________________________\n        //\n        // Gets RTF meta data.\n        //\n        function HandleMeta(t, s, i, o)\n        {\n                if (513 === t)\n                {\n                        o.doc.ver = RtfTkVal(o.tok);\n                        return;\n                }\n\n                var ctl = RtfTkCtl(t, s, i);\n                switch (ctl)\n                {\n                        // ansi/mac/pc/pca: Character Set\n                        case \"ansi\":\n                        case \"mac\":\n                        case \"pc\":\n                        case \"pca\":\n                                o.doc.charset = ctl;\n                                break;\n\n                        // ansicpg: ANSI Code Page\n                        case \"ansicpg\":\n                                o.doc.codepage = RtfTkVal(t);\n                                break;\n\n                        // deff: Default Font (index into fonts[])\n                        case \"deff\":\n                                o.doc.deff = RtfTkVal(t);\n                                break;\n                }\n\n        } // HandleMeta()\n\n        //_[HandleFontTable()]____________________________________________________\n        //\n        // Interprets RTF font table into a 'fonts' list on the document object.\n        // Each font object generally has at least a \"name\" member.\n        //\n        function HandleFontTable(t, s, i, o)\n        {\n                var val = null, ctl = null;\n                if (513 === t)\n                {\n                        if (null == o.doc.fonts)\n                                o.doc.fonts = [ ];\n\n                        ctl = RtfTkCtl(o.tok, s, o.pos);\n                        val = RtfTkVal(o.tok);\n                }\n                else\n                {\n                        ctl = RtfTkCtl(t, s, i);\n                        val = RtfTkVal(t);\n                }\n\n                var typ = (t >> 8) & 0x7;\n                if (1 === typ)\n                {\n                        var txt = RtfTkTxt(t, s, i);\n                        o.font.name = txt;\n                        if (\";\" == o.font.name.charAt(o.font.name.length-1))\n                                o.font.name = o.font.name.substr(0, o.font.name.length-1);\n                        return;\n                }\n\n                switch (ctl)\n                {\n                        // f: New Font\n                        case \"f\":\n                                o.font = o.doc.fonts[val] = new Object;\n                                break;\n\n                        case \"fnil\":\n                        case \"froman\":\n                        case \"fswiss\":\n                        case \"fmodern\":\n                        case \"fscript\":\n                        case \"fdecor\":\n                        case \"ftech\":\n                        case \"fbidi\":\n                                o.font.family = ctl.substr(1);\n                                break;\n\n                        case \"fcharset\":\n                                o.font.charset = val;\n                                break;\n\n                        case \"fprq\":\n                                o.font.pitch = val;\n                                break;\n\n                        case \"ftnil\":\n                        case \"fttruetype\":\n                                o.font.type = ctl.substr(2);\n                                break;\n\n                        case \"cpg\":\n                                o.font.codepage = val;\n                                break;\n                }\n\n        } // HandleFontTable()\n\n        //_[HandleColorTable()]___________________________________________________\n        //\n        // Interprets RTF color table into a 'colors' list on the document object.\n        // Each color object has the members 'r', 'g', and 'b'.\n        //\n        function HandleColorTable(t, s, i, o)\n        {\n                if (513 === t)\n                {\n                        if (null == o.doc.colors)\n                        {\n                                o.color = { r : 0, g : 0, b : 0 };\n                                o.doc.colors = [ o.color ];\n                        }\n                                \n                        return;\n                }\n                else if (769 === t)\n                {\n                        // closing\n                        return;\n                }\n\n                var typ = (t >> 8) & 0x7;\n                if (1 === typ)\n                {\n                        var txt = RtfTkTxt(t, s, i);\n                        if (\";\" == txt)\n                        {\n                                o.color = { r : 0, g : 0, b : 0 };\n                                o.doc.colors.push(o.color);\n                        }\n                        return;\n                }\n                else if (6 !== typ)\n                {\n                        return;\n                }\n\n                var ctl = RtfTkCtl(t, s, i);\n                var val = RtfTkVal(t);\n                if (\"red\" == ctl)\n                {\n                        o.color.r = val;\n                }\n                else if (\"green\" == ctl)\n                {\n                        o.color.g = val;\n                }\n                else if (\"blue\" == ctl)\n                {\n                        o.color.b = val;\n                }\n                else\n                {\n                        throw Error(\"Unrecognized token in color table: \" +\n                                RtfTkTxt(t, s, i));\n                }\n\n        } // HandleColorTable()\n\n} // RtfParser()\n//*[rtf2html.js]*************************[http://code.google.com/p/obremsdk/]*\n//\n// JavaScript: RTF to HTML Conversion\n// Version 0.12\n//\n// Utilizes RtfParser found in rtf.js module.\n//\n//-[History]------------------------------------------------------------------\n// 2007-09-24 by NeilO .... v0.12: Made part of ObremSDK.\n// 2007-03-04 by NeilO .... Created.\n//\n// (C)opyright 2007++ by Neil C. Obremski;                     New BSD License\n//***********************[http://www.opensource.org/licenses/bsd-license.php]*\n\n//_[Rtf2Html()]_______________________________________________________________\n//\n// Highest-level conversion function and easiest to use.  Just call and you'll\n// be returned a string of HTML text.\n//\n// txt .................... [ in] Rich text formatted (RTF) string.\n// baseurl ................ [ in] Base URL for hyperlinks.\n// out .................... [ in] Output object; will contain files to be\n//                                                      written out.\n// ver .................... [ in] Version.  Currently only 2 is supported.\n//\n\n// CUSTOMIZATION HERE. THE FOLLOWING FUNCTION WAS ORIGINALLY DECLARED AS:\n// function Rtf2Html(txt, baseurl, out, ver)\nmodule.exports = function(txt, baseurl, out, ver)\n{\n        var parser = new RtfParser(txt);\n\n        if (null == ver)\n                ver = 2;\n        if (2 != ver)\n                throw Error(\"HTML version \" + ver + \" not supported\");\n\n        parser.HandleDest(\";rtf\", Main_);\n        parser.HandleDest(\"pn\", Bullets_);\n        parser.HandleDest(\"pntxtb\", parser.HandleIgnore);\n        parser.HandleDest(\"pntext\", parser.HandleIgnore);\n        parser.HandleDest(\";rtf;object\", Pkg_);\n        parser.HandleDest(\";rtf;listtext\", ListText_);\n        parser.HandleDest(\";rtf;object;objclass\", parser.HandlePcData);\n        parser.HandleDest(\";rtf;object;objdata\", PkgData_);\n        parser.HandleDest(\";rtf;object;result\", parser.HandleIgnore);\n        parser.HandleDest(\";rtf;rtlch\", Main_);\n        parser.HandleDest(\";rtf;fonttbl;fbiminor\", parser.HandleIgnore);\n        parser.HandleDest(\";rtf;fonttbl;fhiminor\", parser.HandleIgnore);\n        parser.HandleDest(\";rtf;fonttbl;fdbminor\", parser.HandleIgnore);\n        parser.HandleDest(\";rtf;fonttbl;flominor\", parser.HandleIgnore);\n        parser.HandleDest(\";rtf;fonttbl;fbimajor\", parser.HandleIgnore);\n        parser.HandleDest(\";rtf;fonttbl;fhimajor\", parser.HandleIgnore);\n        parser.HandleDest(\";rtf;fonttbl;fdbmajor\", parser.HandleIgnore);\n        parser.HandleDest(\";rtf;fonttbl;flomajor\", parser.HandleIgnore);\n        parser.HandleDest(\";rtf;mmath\", parser.HandleIgnore);\n        parser.HandleDest(\";rtf;info;vern\", parser.HandleIgnore);\n        parser.HandleDest(\";rtf;info;author\", parser.HandleIgnore);\n        parser.HandleDest(\";rtf;info;nofpages\", parser.HandleIgnore);\n        parser.HandleDest(\";rtf;info;nofwords\", parser.HandleIgnore);\n        parser.HandleDest(\";rtf;info;nofcharsws\", parser.HandleIgnore);\n        parser.HandleDest(\";rtf;info;nofchars\", parser.HandleIgnore);\n        parser.HandleDest(\";rtf;info;edmins\", parser.HandleIgnore);\n        parser.HandleDest(\";rtf;info;version\", parser.HandleIgnore);\n        parser.HandleDest(\";rtf;info;revtim\", parser.HandleIgnore);\n        parser.HandleDest(\";rtf;info;creatim\", parser.HandleIgnore);\n        parser.HandleDest(\";rtf;info;operator\", parser.HandleIgnore);\n        parser.HandleDest(\";rtf;info\", parser.HandleIgnore);\n        parser.HandleDest(\";rtf;stylesheet\", parser.HandleIgnore);\n        parser.HandleDest(\";rtf;stylesheet;s\", parser.HandleIgnore);\n        parser.HandleDest(\";rtf;stylesheet;ql\", parser.HandleIgnore);\n        parser.HandleDest(\";rtf;object;result;pict\", parser.HandleIgnore);\n\n        parser.Document(true).baseurl = baseurl;\n        parser.Document(true).outo = out;\n\n        return parser.Document().html;\n\n        //-[Main_()]--------------------------------------------------------------\n        //\n        function Main_(t, s, i, o)\n        {\n                if (513 === t)\n                {\n                        o.newpara = true;\n                        // create string-builder for HTML in this destination\n                        o.html = o.doc.sbhtml = [ ];\n                }\n                else if (769 === t)\n                {\n                        EndPara_();\n\n                        // build string and set it on main document\n                        o.doc.html = o.doc.html || \"\";\n                        o.doc.html += o.html.join(\"\");\n                }\n\n                var typ = RtfTkTyp(t);\n\n                if (1 === typ)\n                {\n                        if (null != o.par_beg)\n                        {\n                                o.html.push(o.par_beg);\n                                o.par_beg = null;\n                        }\n        \n                        if (true == o.newpara)\n                        {\n                                o.lastpari = o.html.length;\n                                o.newpara = false;\n                                Img_(\"LEFT\");\n                        }\n                        else\n                        {\n                                Img_();\n                        }\n\n                        o.html.push(esc_(RtfTkTxt(t, s, i)));\n                        return;\n                }\n                else if (5 === typ)\n                {\n                        o.html.push(esc_(RtfTkChr(t, s, i)));\n                        return;\n                }\n                else if (7 === typ)\n                {\n                        o.html.push(RtfTkHex(t));\n                        return;\n                }\n\n                var ctl = RtfTkCtl(t, s, i);\n                var val = RtfTkVal(t);\n\n                switch (ctl)\n                {\n                        case \"pard\":\n                                EndPara_();\n                                break;\n\n                        case \"tab\":\n                                o.html.push(\"\\t\");\n                                break;\n\n                        case \"li\":\n                                /* Comment out as indented text isn't necessarily a blockquote.\n                                if (o.bullets)\n                                {\n                                        // ignore when bullets are on\n                                }\n                                else if (0 != val)\n                                {\n                                        if (!o.indented)\n                                        {\n                                                o.html.push(\"<BLOCKQUOTE>\");\n                                                o.indented = true;\n                                        }\n                                }\n                                else if (o.indented)\n                                {\n                                }\n                                */\n                                break;\n\n                        case \"f\":\n                                /* Commented out as we have no need for font definitions\n                                o.font = o.doc.fonts[val];\n                                \n                                //WScript.Echo(\"Selected Font \" + val);\n                                //WScript.Echo(\"Font Name: \" + o.font.name + \" (\" + o.font.family + \")\");\n                                \n                                if (o.font.name.match(/(courier|system|fixed)/i))\n                                {\n                                        if (!o.monofont)\n                                        {\n                                                o.monofont = true;\n                                                o.html.push(\"<CODE>\");\n                                        }\n                                }\n                                else if (o.monofont)\n                                {\n                                        o.html.push(\"</CODE>\");\n                                        o.monofont = false;\n                                }\n\n                                */\n                                break;\n\n                        // font size\n                        // case \"fs\":\n\n                        //         if (o.chgsz < 0)\n                        //         {\n                        //                 for ( ; o.chgsz < 0; o.chgsz++)\n                        //                         o.html.push(\"</SMALL>\");\n                        //         }\n                        //         else if (o.chgsz > 0)\n                        //         {\n                        //                 for ( ; o.chgsz > 0; o.chgsz--)\n                        //                         o.html.push(\"</BIG>\");\n                        //         }                               \n\n                        //         switch (val >> 1)\n                        //         {\n                        //                 case 12:\n                        //                         o.chgsz = 1;\n                        //                         o.html.push(\"<BIG>\");\n                        //                         break;\n                        //                 case 10:\n                        //                         break;\n                        //                 case 8:\n                        //                         o.chgsz = -1;\n                        //                         o.html.push(\"<SMALL>\");\n                        //                         break;\n                        //         }\n                        //         break;\n                        \n                        case \"line\":\n                                o.html.push(\"\\n\");\n                                break;\n\n                        case \"par\":\n                                // Img_(\"RIGHT\");\n                                o.newpara = true;\n                                // if (o.bullets)\n                                // {\n                                //         if (o.bulletline)\n                                //         {\n                                //                 o.html.push(\"<BR>\");\n                                //                 o.bulletline = false;\n                                //         }\n                                //         o.html.push(\"</LI>\");\n                                //         o.par_beg = \"<LI>\";\n                                // }\n                                if (null == o.par_end)\n                                {\n                                        o.html.push(\"\\n\");\n                                }\n                                // else\n                                // {\n                                        o.html.push(o.par_end);\n                                        o.par_end = null;\n                                // }\n                                break;\n                        \n                        // case \"qc\":\n                        //         o.center = true;\n                        //         if (0 === val)\n                        //         {\n                        //                 o.center = false;\n                        //                 o.html.push(\"</CENTER>\");\n                        //         }\n                        //         else\n                        //         {\n                        //                 o.html.push(\"<CENTER>\");\n                        //         }\n                        //         break;\n\n                        case \"b\":\n                                if (0 === val)\n                                        o.html.push(\"</B>\");\n                                else\n                                        o.html.push(\"<B>\");\n                                break;\n                        case \"i\":\n                                if (0 === val)\n                                        o.html.push(\"</I>\");\n                                else\n                                        o.html.push(\"<I>\");\n                                break;\n                        // case \"strike\":\n                        //         if (0 === val)\n                        //                 o.html.push(\"</S>\");\n                        //         else\n                        //                 o.html.push(\"<S>\");\n                        //         break;\n                        // case \"ul\":\n                        case \"u\":\n                                if (0 === val)\n                                        o.html.push(\"</EM>\");\n                                else\n                                        o.html.push(\"<EM>\");\n                                break;\n                }\n\n                // end of main (private helpers follow)\n\n                function Img_(align)\n                {\n                        // if (null != o.doc.limg)\n                        // {\n                        //         var imgtag = \"<IMG SRC=\\\"\" + o.doc.baseurl + o.doc.limg.name +\n                        //                 \"\\\" HSPACE=\\\"5\\\" VSPACE=\\\"5\\\" \" +\n                        //                 (null == align ? \"\" : \"ALIGN=\\\"\" + align + \"\\\"\") + \" />\";\n\n                        //         if (\"RIGHT\" == align && null != o.lastpari)\n                        //         {\n                        //                 o.html.splice(o.lastpari, 0, imgtag);\n                        //         }\n                        //         else\n                        //         {\n                        //                 o.html.push(imgtag);\n                        //         }\n\n                        //         o.doc.limg = null;\n                        // }\n                }\n\n                function EndPara_()\n                {\n                        // Img_();\n                        // if (o.center)\n                        // {\n                        //         o.html.push(\"</CENTER>\");\n                        //         o.center = false;\n                        // }\n                        o.newpara = true;\n                        o.bulletline = false;\n                        o.par_beg = null;\n                        // if (o.chgsz < 0)\n                        // {\n                        //         for ( ; o.chgsz < 0; o.chgsz++)\n                        //                 o.html.push(\"</SMALL>\");\n                        // }\n                        // else if (o.chgsz > 0)\n                        // {\n                        //         for ( ; o.chgsz > 0; o.chgsz--)\n                        //                 o.html.push(\"</BIG>\");\n                        // }\n                        // if (o.monofont)\n                        // {\n                        //         o.html.push(\"</CODE>\");\n                        //         o.monofont = false;\n                        // }\n                        // if (o.indented)\n                        // {\n                        //         o.html.push(\"</BLOCKQUOTE>\");\n                        //         o.par_end = \"\";\n                        //         o.indented = false;\n                        // }\n                        // if (o.bullets)\n                        // {\n                        //         o.html.push(\"</UL>\");\n                        //         o.par_end = \"\";\n                        //         o.bullets = false;\n                        // }\n                }\n\n                function esc_(s)\n                {\n                        return s;\n                }\n        }\n\n        //-[Bullets_()]-----------------------------------------------------------\n        function Bullets_(t, s, i, o)\n        {\n                if (513 === t)\n                {\n                        o.stk[o.stk.length-2].bullets = true;\n                        // o.stk[o.stk.length-2].html.push(\"<UL><LI>\");\n                }\n        }\n\n        //-[Bullets_()]-----------------------------------------------------------\n        function ListText_(t, s, i, o)\n        {\n                // if (513 === t)\n                // {\n                //         var bullets = o.stk[o.stk.length-2].bullets;\n                //         o.stk[o.stk.length-2].bullets = true;\n                //         if (!bullets) {\n                //                 o.stk[o.stk.length-2].html.push(\"<UL><LI>\");\n                //         } else {\n                //                 o.stk[o.stk.length-2].html.push(\"</LI><LI>\");\n                //         }\n                // }\n        }\n\n        //-[Pkg_()]---------------------------------------------------------------\n        //\n        function Pkg_(t, s, i, o)\n        {\n                if (513 === t)\n                {\n                        return;\n                }\n                else if (769 === t)\n                {\n                        return;\n                }\n\n                var ctl = RtfTkCtl(t, s, i);\n                var val = RtfTkVal(t);\n\n                switch (ctl)\n                {\n                        case null:\n                                break;\n                        case \"objemb\":\n                                break;\n                        case \"objclass\":\n                                break;\n                        case \"objw\":\n                                break;\n                        case \"objh\":\n                                break;\n                        default:\n                                WScript.Echo(\"Unhandled CTL: \" + ctl);\n                }\n        }\n\n        //-[PkgData_()]-----------------------------------------------------------\n        //\n        function PkgData_(t, s, i, o)\n        {\n                if (769 === t)\n                {\n                        var pfrm = o.stk[o.stk.length - 2];\n\n                        // output a package\n                        if (\"Package\" == pfrm.objclass)\n                        {\n                                var start = o.pos + RtfTkLen(o.tok);\n                                var end = i;\n                                var pkg = RtfPkgOb(s, start, end);\n                                for (var j = 0; j < pkg.items.length; j++)\n                                {\n                                        var item = pkg.items[j];\n                                        if (null != o.doc.outo)\n                                        {\n                                                if (null == o.doc.outo.files)\n                                                        o.doc.outo.files = [ item ];\n                                                else\n                                                        o.doc.outo.files.push(item);\n                                        }\n\n                                        if (item.name.match(/\\.(gif|png|jpe?g)$/i))\n                                        {\n                                                o.doc.limg = item;\n                                        }\n                                        else\n                                        {\n                                                o.doc.sbhtml.push(\"{<A HREF=\\\"\" + o.doc.baseurl +\n                                                        pkg.items[j].name + \"\\\">\" + pkg.items[j].name + \"</A>}\");\n                                        }\n                                }\n                        }\n                }\n        }\n\n\n} // Rtf2Html\n\n\n//# sourceURL=webpack://letterer-helper-plugin/./src/rtf2html/index.js?");

/***/ }),

/***/ "./src/scripts.js":
/*!************************!*\
  !*** ./src/scripts.js ***!
  \************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const ID = __webpack_require__(/*! indesign */ \"?b75f\");\n\nconst setRainbowLayers = __webpack_require__(/*! ./Manga-Scripts/Rainbow Layer Colors.js */ \"./src/Manga-Scripts/Rainbow Layer Colors.js\");\nconst skewFrame = __webpack_require__(/*! ./Manga-Scripts/Skew Frame.js */ \"./src/Manga-Scripts/Skew Frame.js\");\nconst adjustSizeAndLeading = __webpack_require__(/*! ./Manga-Scripts/Adjust Size and Leading.js */ \"./src/Manga-Scripts/Adjust Size and Leading.js\");\n\nconst refitOversetFrames = __webpack_require__(/*! ./Manga-Scripts/Refit Overset Frames.js */ \"./src/Manga-Scripts/Refit Overset Frames.js\"),\n  scalePages = __webpack_require__(/*! ./Manga-Scripts/Scale Pages.js */ \"./src/Manga-Scripts/Scale Pages.js\"),\n  positionArt = __webpack_require__(/*! ./Manga-Scripts/position.js */ \"./src/Manga-Scripts/position.js\"),\n  mangaEmDash = __webpack_require__(/*! ./Manga-Scripts/Manga Em Dash.js */ \"./src/Manga-Scripts/Manga Em Dash.js\"),\n  pseudoStroke = __webpack_require__(/*! ./Manga-Scripts/Pseudo-Stroke.js */ \"./src/Manga-Scripts/Pseudo-Stroke.js\"),\n  typeset = __webpack_require__(/*! ./typeset.js */ \"./src/typeset.js\");\n\nmodule.exports = {\n  setRainbowLayers: setRainbowLayers.main,\n  skewFrame,\n  adjustSizeAndLeading,\n  refitOversetFrames: refitOversetFrames.main,\n  scalePages: scalePages.main,\n  positionArt: positionArt.main,\n  mangaEmDash: mangaEmDash.main,\n  pseudoStroke: pseudoStroke.main,\n  typeset\n}\n\n//# sourceURL=webpack://letterer-helper-plugin/./src/scripts.js?");

/***/ }),

/***/ "./src/typeset.js":
/*!************************!*\
  !*** ./src/typeset.js ***!
  \************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const localStorage = window.localStorage;\n// const sessionStorage = window.sessionStorage;\nconst util = __webpack_require__(/*! ./utility */ \"./src/utility.js\");\n\nconst debugMode = false;\n\nconst defaultCharacterStyleBold = {\n  name: \"Bold\",\n  fontStyle: \"Bold\",\n};\nconst defaultCharacterStyleItalic = {\n  name: \"Italic\",\n  fontStyle: \"Italic\",\n}\nconst defaultCharacterStyleBoldItalic = {\n  name: \"Bold Italic\",\n  fontStyle: \"Bold Italic\",\n}\n\nlet characterStyleBold = undefined,\n  characterStyleItalic = undefined,\n  characterStyleBoldItalic = undefined;\n\napp.scriptPreferences.measurementUnit = ID.MeasurementUnits.PIXELS;\n\n\n// NOTE: this is specific to a given file\nfunction fetchData(key) {\n  let data = localStorage.getItem(currentFile); // string\n  if (!data) return;\n\n  data = JSON.parse(data); // object\n\n  return data[key];\n}\n\n// NOTE: this is specific to a given file\nfunction setData(key, value) {\n  let data = localStorage.getItem(currentFile); // string\n  \n  if (!data) data = {}\n  else data = JSON.parse(data); // object\n\n  data[key] = value;\n\n  data = JSON.stringify(data); // back to string\n  localStorage.setItem(currentFile, data);\n}\n\nlet currentScript, currentFile;\n\nfunction resetData(fileName) {\n  // localStorage.setItem(fileName, \"\"); // empty out the storage for this file\n  currentFile = fileName;\n}\n\nfunction resetDialog(){\n  resetData();\n  stopPasting();\n}\n\n// ----------------------\n//    Settings Overlay\n// ----------------------\n\nfunction toggleSettings() {\n  const panel = document.getElementById(\"typeset_tool\"),\n    overlay = panel.querySelector(\".overlay.settings\");\n\n  const isOpen = overlay.style.display != \"none\";\n\n  panel.classList.toggle(\"settings_open\"); \n  \n  overlay.style.display = isOpen ? \"none\" : \"\";\n\n  // scroll the selection back into view on close\n  if (isOpen && !!selection) selection.scrollIntoView({ behavior: \"smooth\", block: \"center\", inline: \"nearest\" });\n}\n\n// apply previous settings to the UI\nconst settingsList = [\"setting_paste_mode\", \"setting_fit_overset_frames\"];\nconst settingsDefaults = {\n  \"setting_paste_mode\": \"paste_rich\",\n  \"setting_fit_overset_frames\": \"always\"\n};\nfunction setupSettings() {\n  const settingsOverlay = document.querySelector(\".overlay.settings .settings_body\");\n  settingsList.forEach( settingID => {\n    // check if setting exists\n    let settingValue = localStorage.getItem(settingID);\n    if (debugMode) console.log(settingID + \" - \" + settingValue);\n    \n    // if not, then set the data to the default\n    if (!settingValue) {\n      settingValue = settingsDefaults[settingID]\n      localStorage.getItem(settingID, settingValue);\n      if (debugMode) console.log(\"Set to default value: \" + settingValue);\n    }\n    // apply value to UI\n    settingsOverlay.querySelector(`#${settingID}`).value = settingValue;\n    settingsOverlay.querySelector(`#${settingID} .${settingValue}`).checked = true;\n  })\n}\n\nfunction handleSettingChange(e) {\n  if (debugMode) console.log(e.target.id + \" - \" + e.target.value);\n  localStorage.setItem(e.target.id, e.target.value);\n}\n\nasync function copyKeyboardShortcuts(e) {\n  const scriptsPanelFolder = await app.scriptPreferences.scriptsFolder;\n  const pluginFolder = await fsProvider.getPluginFolder();\n\n  try {\n    const scriptsFolderCheck = await fs.lstat(scriptsPanelFolder);\n  } catch (error) {\n    util.showDialog(\"Could not find the Scripts Panel folder for InDesign\", \"Error\");\n  }\n\n  const srcFolder = path.join(pluginFolder.nativePath, \"ExtendScript\");\n  const destFolder = path.join(scriptsPanelFolder.nativePath, \"Manga Helper\");\n  \n  try {\n    const srcFolderCheck = await fs.lstat(srcFolder);\n  } catch (error) {\n    util.showDialog(\"Could not find the assets inside of the plugin to copy into the Scripts Panel folder.\", \"Error\");\n  }\n\n  // create the `Manga Helper` directory in the Scripts Panel folder if it doesn't exist\n  try {\n    const destFolderCheck = await fs.lstat(destFolder);\n  } catch (error) {\n    fs.mkdir(destFolder);\n  }\n\n  // copy over files\n  const files = fs.readdirSync(srcFolder);\n  for (let i = 0; i < files.length; i++) {\n    await fs.copyFile( path.join(srcFolder, files[i]), path.join(destFolder, files[i]) );\n  }\n\n  util.showDialog(\"All scripts have been copied into InDesign. Open the Keyboard Shortcuts dialog in InDesign and assign shortcuts to each Script.\", \"Success\");\n}\n\n\n// ----------------------\n//  End Settings Overlay\n// ----------------------\n\n\nasync function getText() {\n  // Ask user to select a file\n  if (fsProvider.isFileSystemProvider) {\n\n    try {\n      const file = await fsProvider.getFileForOpening({ types: [ \"txt\", \"rtf\" ] });\n      if (!file) { \n        togglePanelLoading();\n        return false;\n      } // no file selected\n\n      let text;\n      try {\n        text = await file.read(); // try utf-8 encoding\n      } catch (textError){\n        text = await file.read({format: formats.binary}); // try binary encoding\n        // if that doesn't work, the parent try/catch will show an error\n      }\n\n      stopPasting();\n      togglePanelLoading();\n\n      resetData(file.name);\n      \n      return parseScript(text, file.name);\n    } catch (err) {\n      console.log(err);\n      if (!text) util.showDialog(\"An error occurred while loading the script file.<br>\" + err.message, \"Error\");\n    }\n  }\n}\n\n/* \n  Parses script into this shape:\n    {\n      1: {\n        1.1: [\n          [\"Caption:\", \"It is a truth universally acknowledged, that a…\"],\n          [\"Mrs. Bennet:\", \"My dear Mr. Bennet,\"]\n        ]\n      }\n      2: {\n        2.1: [\n          [\"Mrs. Bennet:\", \"You must know that I am thinking of his marrying one…\"],\n          [\"Mrs. Bennet/aside:\", \"You have no compassion on my poor nerves.\"]\n        ]\n      }\n    }\n*/\nfunction parseScript(script, fileName) {\n  currentScript = {};\n  // TODO: try to guess the shape of the script + support more types\n\n  let fileType = fileName.split('.').pop();\n  try {\n    if (fileType == \"txt\") { \n      return parseTxt(script);\n    } else if (fileType == \"rtf\") {\n      return parseRtf(script);\n    }\n  } catch (err) {\n    console.log(err);\n    util.showDialog(\"An error occurred while parsing the script.<br>\" + err.message, \"Error\");\n    return false;\n  }\n}\n\nfunction parseRtf(script) {\n  // google adds a space after \\u0000 unicode that shows up in the parsed file\n  script = script.replaceAll(/(\\\\u\\d{4}) \\}/gi, \"$1}\");\n  // change all curly quotes to straight\n  // the RTF parser doesn't handle them... TODO: fix?\n  script = script.replaceAll(/\\\\'9[12]/gi, \"'\"); // replace singles\n  script = script.replaceAll(/\\\\'9[34]/gi, \"\\\"\"); // replace doubles\n  // console.log(script);\n\n  const rtfParser = __webpack_require__(/*! ./rtf2html/index.js */ \"./src/rtf2html/index.js\");\n  const scriptHTML = rtfParser(script);\n\n  return parseTxt(scriptHTML);\n}\n\nfunction parseTxt(script) {\n  if (debugMode) {\n    console.log(\"---- parsing -----\")\n    console.log(script);\n  }\n  const lines = script.split(\"\\n\");\n  let parsedScript = {},\n      columnsCount = 1,\n      lastPanelNum = 0.0,\n      lastPageNum = 0;\n  \n  lines.forEach( line => {\n    if (line.length < 1 || line.toLowerCase().startsWith(\"page\")) return;\n\n    // remove newlines\n    line = line.replaceAll(/(\\r\\n|\\n|\\r)/gm, \"\");\n    \n    // remove extra closing tags\n    // thanks 4 nothing google drive\n    b_closes = (line.match(/<\\/B>/g) || []).length\n    b_opens = (line.match(/<B>/g) || []).length\n    if (b_closes > b_opens) { \n      for (var i = 0; i < b_closes - b_opens; i++) { \n        lastIndex = line.lastIndexOf(\"</B>\");\n        line = line.substring(0, lastIndex) + line.substring(lastIndex + 4, line.length);\n      }\n    }\n    i_closes = (line.match(/<\\/I>/gi) || []).length\n    i_opens = (line.match(/<I>/gi) || []).length\n    if (i_closes > i_opens) { \n      for (var i = 0; i < i_closes - i_opens; i++) { \n        lastIndex = line.toUpperCase().lastIndexOf(\"</I>\");\n        line = line.substring(0, lastIndex) + line.substring(lastIndex + 4, line.length);\n      }\n    }\n\n    let lineData = line.split('\\t'),\n      panelNum = parseFloat(lineData[0]) || lastPanelNum,\n      pageNum = Math.floor(panelNum);\n\n    // if no page number is provided, storebought is fine\n    if (!pageNum) pageNum = lastPageNum\n    else if (pageNum != lastPageNum) lastPageNum = pageNum;\n    lastPanelNum = panelNum; // update which panel was processed last\n\n    let pageData = parsedScript[pageNum] || {},\n        panelData = pageData[panelNum] || [];\n    // pop out panel number if it's in there\n    if (parseFloat(lineData[0]) || lineData[0] == \"\") lineData.shift();\n    // add the line data into the panel \n    panelData.push(lineData);\n    // update the max number of columns\n    if (columnsCount < lineData.length) columnsCount = lineData.length;\n    // update panel in the page\n    pageData[panelNum] = panelData;\n    // update the page in the whole script\n    parsedScript[pageNum] = pageData;\n  })\n\n  if (debugMode) console.log(parsedScript);\n  return [parsedScript, columnsCount];\n}\n\nfunction setupTable(parsedScript, columnsCount) {\n  if (!parsedScript) return; \n  \n  try {\n    // DOM elements\n    const panel = document.getElementById(\"typeset_tool\"),\n      overlay = panel.querySelector('.overlay'),\n      controls = panel.querySelector('.control_wrapper'),\n      tableWrapper = panel.querySelector(\".table_wrapper\"),\n      tableHead = tableWrapper.querySelector(\".table_head\"),\n      tableBody = tableWrapper.querySelector(\".table_body\");\n    // templates\n    const templateHead = panel.querySelector(\"#template_head div\").cloneNode(true), // true == deep clone\n      templatePage = panel.querySelector(\"#template_page div\").cloneNode(true),\n      templatePanel = templatePage.querySelector('.table_page_panel').cloneNode(true),\n      templateLine = templatePanel.querySelector(\".table_row\").cloneNode(true),\n      templateCell = templateLine.querySelector(\".table_cell\").cloneNode(true);\n\n    // lightly adapted from source: https://stackoverflow.com/questions/58660470/resizing-column-width-on-a-table\n    function setListeners(div) {\n      let pageX, curCol, curColWidth;\n\n      div.addEventListener('mousedown', function(e) { \n        curCol = e.target.parentElement;\n        pageX = e.pageX;\n\n        let padding = paddingDiff(curCol);\n\n        curColWidth = curCol.offsetWidth - padding;\n      });\n\n      document.addEventListener('mousemove', function(e) {\n        if (curCol) {\n          let diffX = e.pageX - pageX,\n              newWidth = (curColWidth + diffX) + 'px',\n              columnId = curCol.getAttribute(\"column-id\"),\n              cells = tableWrapper.querySelectorAll(`.table_cell[column-id=\"${columnId}\"]`);\n\n          cells.forEach(cell => { \n            cell.style.minWidth = newWidth;\n            cell.style.maxWidth = newWidth;\n          });\n        }\n      });\n\n      document.addEventListener('mouseup', function(e) {\n        curCol = undefined;\n        pageX = undefined;\n        curColWidth = undefined\n      });\n    }\n\n    function paddingDiff(col) {\n      if (getStyleVal(col, 'box-sizing') == 'border-box') {\n        return 0;\n      }\n\n      var padLeft = getStyleVal(col, 'padding-left');\n      var padRight = getStyleVal(col, 'padding-right');\n      return (parseInt(padLeft) + parseInt(padRight));\n\n    }\n\n    function getStyleVal(elm, css) {\n      return (window.getComputedStyle(elm, null).getPropertyValue(css))\n    }\n    // end stackoverflow source\n\n    // fill table header\n    tableHead.innerHTML = \"\";\n    let thisHeader;\n    for ( let i = 0; i < columnsCount; i++ ) {\n      thisHeader = templateHead.cloneNode(true);\n      thisHeader.querySelector(\".table_column_name\").innerHTML = i + 1;\n      thisHeader.setAttribute(\"column-id\", i);\n\n      setListeners(thisHeader);\n\n      tableHead.appendChild(thisHeader);\n    }\n\n    // fill table body\n    tableBody.innerHTML = \"\";\n    Object.entries(parsedScript).forEach( (page, pageIndex) => {\n      let pageNum = page[0],\n          pageData = page[1],\n          rowIndex = 0,\n          thisPage = templatePage.cloneNode(true);\n\n      thisPage.removeChild(thisPage.querySelector(\".table_page_panel\"));\n      thisPage.querySelector(\".page_num\").innerHTML = pageNum;\n\n      Object.entries(pageData).forEach( (panel, panelIndex) => {\n        let panelData = panel[1],\n            panelNum = panel[0],\n            thisPanel = templatePanel.cloneNode(true);\n        thisPanel.querySelector(\".panel_num\").innerHTML = panelNum;\n        thisPanel.removeChild(thisPanel.querySelector(\".table_row\"));\n\n        panelData.forEach( (line, lineIndex) => {\n          let thisLine = templateLine.cloneNode(true);\n              thisLine.innerHTML = \"\";\n          \n          line.forEach( (cell, cellIndex) => {\n            let thisCell = templateCell.cloneNode(true),\n                cellId = `${pageIndex}-${panelIndex}-${lineIndex}-${cellIndex}`;\n            thisCell.setAttribute(\"page-id\", pageIndex);\n            thisCell.setAttribute(\"cell-id\", cellId);\n            thisCell.setAttribute(\"row-id\", rowIndex);\n            thisCell.setAttribute(\"column-id\", cellIndex);\n            thisCell.innerHTML = cell + (!debugMode ? \"\" :  \" [\" + [pageIndex, cellIndex, rowIndex].join(\", \") + \"]\");\n            thisLine.appendChild(thisCell);\n            thisCell.onclick = changeSelection;\n\n            // store the value in global hash\n            currentScript[cellId] = cell;\n          }) // forEach cell\n\n          if (line.length > 0) rowIndex++; // increment row index\n          thisPanel.appendChild(thisLine);\n        }); // forEach line\n\n        thisPage.appendChild(thisPanel);\n      }) // forEach panel\n\n      tableBody.appendChild(thisPage);\n    }) // forEach page\n\n    overlay.style.display = \"none\";\n    tableWrapper.style.display = \"\";\n    controls.style.display = \"\";\n    controls.classList.remove(\"closed\");\n\n    togglePanelLoading();\n\n  } catch(err) { \n    console.log(err);\n    util.showDialog(\"An error occurred while setting up the script table.<br>\" + err.message, \"Error\");\n  }\n}\n\nfunction togglePanelLoading(isLoading) {\n  let panel = document.getElementById(\"typeset_tool\"),\n      overlay = panel.querySelector(\".overlay.loading\");\n\n  if (isLoading !== undefined) {\n    // if given a value, use that\n    isLoading ? panel.classList.add(\"loading\") : panel.classList.remove(\"loading\");\n\n  } else {\n    // otherwise just toggle, return value is whether or not the class was added \n    isLoading = panel.classList.toggle(\"loading\"); \n  }\n\n  overlay.style.display = isLoading ? \"\" : \"none\";\n}\n\nvar isPasting = false,\n    selection = null;\n\nfunction startPasting() {\n  try {\n    isPasting = true;\n\n    let panel = document.getElementById(\"typeset_tool\");\n    panel.querySelector(\".control_wrapper .start\").style.display = \"none\";\n    panel.querySelector(\".control_wrapper .stop\").style.display = \"\";\n\n    const lastSelection = fetchData(\"lastSelection\");\n    let thisSelection = null;\n    if (lastSelection) {\n      thisSelection = panel.querySelector('.table_body').querySelector(`.table_cell[cell-id=\"${lastSelection}\"]`);\n      if (thisSelection) thisSelection.classList.add(\"history-selection\");\n    } else if (selection) {\n      thisSelection = selection;\n    } else {\n      // select the first cell \n      thisSelection = panel.querySelector('.table_body').querySelector(\".table_cell\");\n    }\n    setSelection(thisSelection);\n\n    panel.querySelector(\".table_wrapper\").classList.add(\"pasting\");\n  } catch(err) { \n    console.log(err);\n    util.showDialog(\"An error occurred while starting to paste.<br>\" + err.message, \"Error\");\n  }\n}\n\nfunction stopPasting() {\n  isPasting = false;\n\n  let panel = document.getElementById(\"typeset_tool\");\n  panel.querySelector(\".control_wrapper .start\").style.display = \"\";\n  panel.querySelector(\".control_wrapper .stop\").style.display = \"none\";\n\n  if (selection) {\n    setData(\"lastSelection\", selection.getAttribute('cell-id'));\n  }\n\n  setSelection(undefined);\n  \n  panel.querySelector(\".table_wrapper\").classList.remove(\"pasting\");\n}\n\nfunction changeSelection(e) {\n  if (!isPasting) return;\n\n  let target = e.target.closest(\".table_cell\");\n\n  document.querySelectorAll('.table_cell.history-selection').forEach( cell => cell.classList.remove(\"history-selection\"));\n\n  setSelection(target);\n}\n\nfunction setSelection(cell){\n  let panel = document.getElementById(\"typeset_tool\");\n  panel.querySelector(\".table_body\").querySelectorAll(\".table_cell.selected\").forEach( cell => cell.classList.remove(\"selected\") );\n    \n  selection = cell;\n\n  if (!cell) return; // skip if empty\n\n  selection.classList.add(\"selected\");\n  selection.scrollIntoView({ behavior: \"smooth\", block: \"center\", inline: \"nearest\" });\n}\n\nfunction goToNextCell(direction = \"next\") {\n  const pageId = selection.getAttribute(\"page-id\"),\n    colId = selection.getAttribute(\"column-id\"),\n    rowId = selection.getAttribute(\"row-id\"),\n    increment = (direction == \"prev\") ? -1 : 1;\n  \n  // try going to the next row\n  let query = `.table_cell[page-id=\"${pageId}\"][column-id=\"${colId}\"][row-id=\"${parseInt(rowId) + increment}\"]`,\n    newSelection = document.querySelector(\"#typeset_tool .table_body\").querySelector(query);\n\n  // if empty, try the next next row\n  if (!newSelection) {\n    query = `.table_cell[page-id=\"${pageId}\"][column-id=\"${colId}\"][row-id=\"${parseInt(rowId) + (increment * 2)}\"]`;\n    newSelection = document.querySelector(\"#typeset_tool .table_body\").querySelector(query);\n  }\n  \n  // if empty, go to next page in the same column\n  if (!newSelection) {\n    query = `.table_cell[page-id=\"${parseInt(pageId) + increment}\"][column-id=\"${colId}\"][row-id=\"0\"]`;\n    newSelection = document.querySelector(\"#typeset_tool .table_body\").querySelector(query);\n  }\n\n  // if STILL empty, try the second row in the next page\n  if (!newSelection) {\n    query = `.table_cell[page-id=\"${parseInt(pageId) + increment}\"][column-id=\"${colId}\"][row-id=\"1\"]`;\n    newSelection = document.querySelector(\"#typeset_tool .table_body\").querySelector(query);\n  }\n\n  // if STILL empty, try the previous column\n  if (!newSelection) {\n    query = `.table_cell[page-id=\"${parseInt(pageId) + increment}\"][column-id=\"${colId - 1}\"][row-id=\"1\"]`;\n    newSelection = document.querySelector(\"#typeset_tool .table_body\").querySelector(query);\n  }\n    \n  setSelection(newSelection);\n  \n  return newSelection;\n}\n\n// TODO: store progress for each file, and skip to the last used line on load\n\nfunction loadScript() {\n  const textPromise = getText();\n\n  textPromise.then((data) => { \n    if (!data) { // no file selected, or there was an issue with the file\n      togglePanelLoading();\n    } else {\n      setupTable(...data);\n    }\n  });\n}\n\nfunction selectionChanged() {\n  const doc = app.activeDocument;\n  if (isPasting && doc.selection[0] instanceof ID.TextFrame && doc.selection[0].contents == '' && doc.selection[1] == null) {\n    pasteText();\n  }\n}\n\n// recursive function that nudges the frame bounds out by 1\n// until the frame is no longer overset\nconst doFit = function(frame) {\n  if (!!frame && !frame.overflows) return;\n  expandFrame(frame, 1);\n  doFit(frame);\n}\n\n// expands a given frame by a given unit\nconst expandFrame = function(frame, by) {\n  frame.geometricBounds = transformCoords(frame.geometricBounds, [by * -1, by * -1, by, by]);\n}\n\n// applies transformations in the format [y1, x1, y2, x2]\nconst transformCoords = function(src, trns) {\n    return [\n        src[0] + trns[0],\n        src[1] + trns[1],\n        src[2] + trns[2],\n        src[3] + trns[3]\n    ];\n}\n\nfunction applyTextStyles(textFrame) {\n  const doc = app.activeDocument;\n  // Check to see if the Character Style already exists\n  if (!characterStyleBold) {\n    var existingStyleBold = doc.characterStyles.itemByName(defaultCharacterStyleBold.name);\n    characterStyleBold = existingStyleBold.isValid ?\n        existingStyleBold :\n        doc.characterStyles.add(defaultCharacterStyleBold);\n  }\n  if (!characterStyleItalic) {\n    var existingStyleItalic = doc.characterStyles.itemByName(defaultCharacterStyleItalic.name);\n    characterStyleItalic = existingStyleItalic.isValid ?\n        existingStyleItalic :\n        doc.characterStyles.add(defaultCharacterStyleItalic);\n  }\n  if (!characterStyleBoldItalic) {\n    var existingStyleBoldItalic = doc.characterStyles.itemByName(defaultCharacterStyleBoldItalic.name);\n    characterStyleBoldItalic = existingStyleBoldItalic.isValid ?\n        existingStyleBoldItalic:\n        doc.characterStyles.add(defaultCharacterStyleBoldItalic);\n  }\n  \n  doApplyTextStyles(textFrame, \"<b>\", \"</b>\", characterStyleBold);\n  doApplyTextStyles(textFrame, \"<i>\", \"</i>\", characterStyleItalic);\n}\n\n\nfunction doApplyTextStyles(textFrame, modifierStart, modifierEnd, characterStyle) {\n  // todo: this is slow\n  var characters = textFrame.characters;\n  var testString, start, end;\n\n  // if frame is overflowing/overset, then refit\n  // overset text isn't formattable\n  var fitOversetFramesSetting = localStorage.getItem(\"setting_fit_overset_frames\");\n  if (textFrame.overflows && ((!fitOversetFramesSetting || fitOversetFramesSetting != \"only_rich_text\") || textFrame.contents.match(/<.+>/))) {\n    doFit(textFrame);\n  }\n  for (i = 0; i < characters.count() - modifierEnd.length; i++) {\n    start = undefined;\n    testString = characters.itemByRange(i, i + modifierStart.length - 1).contents.join(\"\").toLowerCase();\n    if (testString == modifierStart) {\n      start = i + modifierStart.length;\n      end = undefined;\n      \n      for (j = start; end == undefined && j < characters.count() - modifierEnd.length + 1; j++) {\n        testString = characters.itemByRange(j, j + modifierEnd.length - 1).contents.join(\"\").toLowerCase();\n        if (end == undefined && testString == modifierEnd) {\n          end = j - 1;\n        }\n      }\n\n      // tag that has no closer\n      if (start != undefined && end == undefined) {\n        end = characters.count() - 1;\n      }\n\n      if (start != undefined && end != undefined) {\n        let boldItalicList = [];\n        // apply Bold Italic if some text is already bold and we're adding italic\n        if (characterStyle.name == characterStyleItalic.name) {\n          let boldItalStart = undefined;\n          // check for bold italic styling, put boldital blocks in an array\n          for(let k = start; k <= end; k++) {\n            let char = characters.item(k);\n            if (!boldItalStart && char.appliedCharacterStyle.name == characterStyleBold.name) {\n              boldItalStart = k;\n            } else if(!!boldItalStart && char.appliedCharacterStyle.name != characterStyleBold.name) { \n              boldItalicList.push([boldItalStart, k]);\n              boldItalStart = undefined;\n            } else if (!!boldItalStart && k == end) {\n              boldItalicList.push([boldItalStart, k]);\n            }\n          }\n        }\n\n        characters.itemByRange(start, end).applyCharacterStyle(characterStyle);\n        // assign boldital style \n        boldItalicList.forEach((pair) => {\n          characters.itemByRange(...pair).applyCharacterStyle(characterStyleBoldItalic);\n        });\n\n        if (textFrame.overflows) {\n          doFit(textFrame);\n        }\n        \n        // remove tags\n        // make sure there was an end tag first... \n        var endTag = characters.itemByRange(end + 1, end + modifierEnd.length);\n        if (endTag.isValid) {\n          characters.itemByRange(end + 1, end + modifierEnd.length).remove();\n        }\n        characters.itemByRange(i, start - 1).remove();\n      }\n    }\n  }\n}\n\nfunction pasteText() {\n  if (!currentScript || !selection) return;\n  const doc = app.activeDocument,\n    cellId = selection.getAttribute(\"cell-id\");\n\n  let textToPlace = currentScript[cellId];\n  let textFrame = doc.selection[0];\n  // textToPlace = decodeURI(textToPlace); // unescape HTML (like quotes)\n\n  // respect the setting for paste mode\n  const pasteModeSetting = localStorage.getItem(\"setting_paste_mode\");\n  if (pasteModeSetting == \"paste_rich\" || !pasteModeSetting) {\n    // place text, then format + remove tags\n    textFrame.contents = textToPlace;\n    applyTextStyles(textFrame);\n  } else {\n    // remove html tags, then place text\n    textToPlace = textToPlace.replace(/<\\/?[^>]+(>|$)/g, \"\");\n    textFrame.contents = textToPlace;\n    if (localStorage.getItem(\"setting_fit_overset_frames\") != \"only_rich_text\") {\n      doFit(textFrame);\n    }\n  }\n\n  // go to next line\n  const newSelection = goToNextCell();\n  if (!newSelection) { stopPasting() } // end of file\n}\n\n\nfunction setupButtons() {\n  let panel = document.getElementById(\"typeset_tool\");\n  panel.querySelectorAll(\".load_script\").forEach(btn => btn.onclick = loadScript);\n\n  stopPasting();\n\n  characterStyleBold = undefined,\n  characterStyleItalic = undefined,\n  characterStyleBoldItalic = undefined;\n\n  panel.querySelector(\".control_wrapper .start\").onclick = startPasting;\n  panel.querySelector(\".control_wrapper .stop\").onclick = stopPasting;\n  panel.querySelectorAll(\".toggle_settings\").forEach(btn => btn.onclick = toggleSettings);\n  panel.querySelector(\".control_wrapper_toggle\").onclick = toggleControlWrapper(panel);\n\n  if (app.documents.length > 0) {\n    app.activeDocument.removeEventListener('afterSelectionChanged', selectionChanged);\n    app.activeDocument.addEventListener('afterSelectionChanged', selectionChanged);\n  }\n\n  // Settings Overlay\n  setupSettings();\n\n  panel.querySelectorAll(\".load_script\").forEach(btn => btn.onclick = loadScript);\n  panel.querySelectorAll('.settings_body .setting_persist').forEach(btn => btn.addEventListener(\"change\", handleSettingChange));\n  panel.querySelector(\"#copy-keyboard-shortcuts\").onclick = copyKeyboardShortcuts;\n}\n\nfunction handlePressNextRow(evt) {\n  if (!isPasting) return; \n\n  goToNextCell();\n}\n\nfunction handlePressPrevRow(evt) {\n  if (!isPasting) return; \n\n  goToNextCell(\"prev\");\n}\n\nfunction toggleControlWrapper(panel) {\n  return function(evt) { \n    const controlWrapper = panel.querySelector(\".control_wrapper\");\n    controlWrapper.classList.toggle(\"closed\");\n  }\n}\n\nfunction setupKeyboardShortcuts() {\n  var nextRowMenuItem = app.scriptMenuActions.item(\"Manga Helper - Go to Next Row\");\n  if (!nextRowMenuItem.isValid) {\n    nextRowMenuItem = app.scriptMenuActions.add(\"Manga Helper - Go to Next Row\");\n  }\n  \n  nextRowMenuItem.removeEventListener(\"afterInvoke\", handlePressNextRow);\n  nextRowMenuItem.addEventListener(\"afterInvoke\", handlePressNextRow);\n\n\n  var prevRowMenuItem = app.scriptMenuActions.item(\"Manga Helper - Go to Previous Row\");\n  if (!prevRowMenuItem.isValid) {\n    prevRowMenuItem = app.scriptMenuActions.add(\"Manga Helper - Go to Previous Row\");\n  }\n  \n  prevRowMenuItem.removeEventListener(\"afterInvoke\", handlePressPrevRow);\n  prevRowMenuItem.addEventListener(\"afterInvoke\", handlePressPrevRow);\n}\n\nmodule.exports = { \n  setupButtons,\n  setupKeyboardShortcuts\n}\n\n//# sourceURL=webpack://letterer-helper-plugin/./src/typeset.js?");

/***/ }),

/***/ "./src/utility.js":
/*!************************!*\
  !*** ./src/utility.js ***!
  \************************/
/***/ ((module) => {

eval("function closeDialog(dialog) {\n    return (_event) => {\n        dialog.close();\n    }\n}\n\nfunction updateProgressBar(progress) {\n    const dialog = document.getElementById(\"dialog\");\n\n    dialog.querySelector(\".overlay.loading sp-progressbar\").setAttribute(\"value\", progress);\n}\n\nconst showDialog = function(message, title) {\n    const dialog = document.querySelector(\"dialog\");\n  \n    dialog.querySelector(\".title\").innerHTML = title || \"\";\n    dialog.querySelector(\".message\").innerHTML = message || \"\";\n    dialog.show();\n  \n    dialog.querySelector(\".close\").onclick = closeDialog(dialog);\n}\n\nmodule.exports = {\n    showDialog\n}\n\n//# sourceURL=webpack://letterer-helper-plugin/./src/utility.js?");

/***/ }),

/***/ "?b75f":
/*!**************************!*\
  !*** indesign (ignored) ***!
  \**************************/
/***/ (() => {

eval("/* (ignored) */\n\n//# sourceURL=webpack://letterer-helper-plugin/indesign_(ignored)?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/inputs.js");
/******/ 	
/******/ })()
;